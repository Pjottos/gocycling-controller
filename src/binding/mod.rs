#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]

pub mod impls;

/* automatically generated by rust-bindgen 0.58.1 */

pub const PICO_DEFAULT_UART: u32 = 0;
pub const PICO_DEFAULT_UART_TX_PIN: u32 = 0;
pub const PICO_DEFAULT_UART_RX_PIN: u32 = 1;
pub const PICO_DEFAULT_LED_PIN: u32 = 25;
pub const PICO_DEFAULT_I2C: u32 = 0;
pub const PICO_DEFAULT_I2C_SDA_PIN: u32 = 4;
pub const PICO_DEFAULT_I2C_SCL_PIN: u32 = 5;
pub const PICO_DEFAULT_SPI: u32 = 0;
pub const PICO_DEFAULT_SPI_SCK_PIN: u32 = 18;
pub const PICO_DEFAULT_SPI_TX_PIN: u32 = 19;
pub const PICO_DEFAULT_SPI_RX_PIN: u32 = 16;
pub const PICO_DEFAULT_SPI_CSN_PIN: u32 = 17;
pub const PICO_BOOT_STAGE2_CHOOSE_W25Q080: u32 = 1;
pub const PICO_FLASH_SPI_CLKDIV: u32 = 2;
pub const PICO_FLASH_SIZE_BYTES: u32 = 2097152;
pub const PICO_SMPS_MODE_PIN: u32 = 23;
pub const PICO_FLOAT_SUPPORT_ROM_V1: u32 = 1;
pub const PICO_DOUBLE_SUPPORT_ROM_V1: u32 = 1;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _GLIBCXX_CXX_CONFIG_H: u32 = 1;
pub const _GLIBCXX_RELEASE: u32 = 10;
pub const __GLIBCXX__: u32 = 20210422;
pub const _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY: u32 = 1;
pub const _GLIBCXX_USE_DEPRECATED: u32 = 1;
pub const _GLIBCXX_EXTERN_TEMPLATE: u32 = 1;
pub const _GLIBCXX_USE_DUAL_ABI: u32 = 1;
pub const _GLIBCXX_USE_CXX11_ABI: u32 = 1;
pub const _GLIBCXX_INLINE_VERSION: u32 = 0;
pub const _GLIBCXX_USE_ALLOCATOR_NEW: u32 = 1;
pub const _GLIBCXX_OS_DEFINES: u32 = 1;
pub const __NO_CTYPE: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_ISOCXX11: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_XOPEN_EXTENDED: u32 = 1;
pub const __USE_UNIX98: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __USE_XOPEN2K8XSI: u32 = 1;
pub const __USE_XOPEN2KXSI: u32 = 1;
pub const __USE_LARGEFILE: u32 = 1;
pub const __USE_LARGEFILE64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 32;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 32;
pub const __WORDSIZE32_SIZE_ULONG: u32 = 0;
pub const __WORDSIZE32_PTRDIFF_LONG: u32 = 0;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 0;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 0;
pub const _GLIBCXX_CPU_DEFINES: u32 = 1;
pub const _GLIBCXX_FAST_MATH: u32 = 0;
pub const _GLIBCXX_USE_FLOAT128: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_AGGREGATE: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_LAUNDER: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED: u32 = 1;
pub const _GLIBCXX_HAVE_ACOSF: u32 = 1;
pub const _GLIBCXX_HAVE_ACOSL: u32 = 1;
pub const _GLIBCXX_HAVE_ALIGNED_ALLOC: u32 = 1;
pub const _GLIBCXX_HAVE_ARPA_INET_H: u32 = 1;
pub const _GLIBCXX_HAVE_ASINF: u32 = 1;
pub const _GLIBCXX_HAVE_ASINL: u32 = 1;
pub const _GLIBCXX_HAVE_AS_SYMVER_DIRECTIVE: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2F: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2L: u32 = 1;
pub const _GLIBCXX_HAVE_ATANF: u32 = 1;
pub const _GLIBCXX_HAVE_ATANL: u32 = 1;
pub const _GLIBCXX_HAVE_ATOMIC_LOCK_POLICY: u32 = 1;
pub const _GLIBCXX_HAVE_AT_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_CEILF: u32 = 1;
pub const _GLIBCXX_HAVE_CEILL: u32 = 1;
pub const _GLIBCXX_HAVE_COMPLEX_H: u32 = 1;
pub const _GLIBCXX_HAVE_COSF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHL: u32 = 1;
pub const _GLIBCXX_HAVE_COSL: u32 = 1;
pub const _GLIBCXX_HAVE_DIRENT_H: u32 = 1;
pub const _GLIBCXX_HAVE_DLFCN_H: u32 = 1;
pub const _GLIBCXX_HAVE_ENDIAN_H: u32 = 1;
pub const _GLIBCXX_HAVE_EXCEPTION_PTR_SINCE_GCC46: u32 = 1;
pub const _GLIBCXX_HAVE_EXECINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_EXPF: u32 = 1;
pub const _GLIBCXX_HAVE_EXPL: u32 = 1;
pub const _GLIBCXX_HAVE_FABSF: u32 = 1;
pub const _GLIBCXX_HAVE_FABSL: u32 = 1;
pub const _GLIBCXX_HAVE_FCNTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_FENV_H: u32 = 1;
pub const _GLIBCXX_HAVE_FINITE: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEF: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEL: u32 = 1;
pub const _GLIBCXX_HAVE_FLOAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORF: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORL: u32 = 1;
pub const _GLIBCXX_HAVE_FMODF: u32 = 1;
pub const _GLIBCXX_HAVE_FMODL: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPF: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPL: u32 = 1;
pub const _GLIBCXX_HAVE_GETIPINFO: u32 = 1;
pub const _GLIBCXX_HAVE_GETS: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOT: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTF: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTL: u32 = 1;
pub const _GLIBCXX_HAVE_ICONV: u32 = 1;
pub const _GLIBCXX_HAVE_INT64_T: u32 = 1;
pub const _GLIBCXX_HAVE_INT64_T_LONG_LONG: u32 = 1;
pub const _GLIBCXX_HAVE_INTTYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFF: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFL: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANF: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANL: u32 = 1;
pub const _GLIBCXX_HAVE_ISWBLANK: u32 = 1;
pub const _GLIBCXX_HAVE_LC_MESSAGES: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPF: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPL: u32 = 1;
pub const _GLIBCXX_HAVE_LIBINTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_AS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_DATA: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_FSIZE: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_RSS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_VMEM: u32 = 0;
pub const _GLIBCXX_HAVE_LINK: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_FUTEX: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_RANDOM_H: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOCALE_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10F: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10L: u32 = 1;
pub const _GLIBCXX_HAVE_LOGF: u32 = 1;
pub const _GLIBCXX_HAVE_LOGL: u32 = 1;
pub const _GLIBCXX_HAVE_MBSTATE_T: u32 = 1;
pub const _GLIBCXX_HAVE_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_MEMORY_H: u32 = 1;
pub const _GLIBCXX_HAVE_MODF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFL: u32 = 1;
pub const _GLIBCXX_HAVE_NETDB_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_IN_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_TCP_H: u32 = 1;
pub const _GLIBCXX_HAVE_POLL: u32 = 1;
pub const _GLIBCXX_HAVE_POLL_H: u32 = 1;
pub const _GLIBCXX_HAVE_POSIX_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_POWF: u32 = 1;
pub const _GLIBCXX_HAVE_POWL: u32 = 1;
pub const _GLIBCXX_HAVE_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_READLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SETENV: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOS: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSF: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSL: u32 = 1;
pub const _GLIBCXX_HAVE_SINF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHL: u32 = 1;
pub const _GLIBCXX_HAVE_SINL: u32 = 1;
pub const _GLIBCXX_HAVE_SOCKATMARK: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTF: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTL: u32 = 1;
pub const _GLIBCXX_HAVE_STDALIGN_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDBOOL_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDINT_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDLIB_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_L: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_R: u32 = 1;
pub const _GLIBCXX_HAVE_STRINGS_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRING_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOF: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOLD: u32 = 1;
pub const _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE: u32 = 1;
pub const _GLIBCXX_HAVE_STRXFRM_L: u32 = 1;
pub const _GLIBCXX_HAVE_SYMLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IOCTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IPC_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_PARAM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_RESOURCE_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SDT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SEM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SOCKET_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STATVFS_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SYSINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_UIO_H: u32 = 1;
pub const _GLIBCXX_HAVE_S_ISREG: u32 = 1;
pub const _GLIBCXX_HAVE_TANF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHL: u32 = 1;
pub const _GLIBCXX_HAVE_TANL: u32 = 1;
pub const _GLIBCXX_HAVE_TGMATH_H: u32 = 1;
pub const _GLIBCXX_HAVE_TIMESPEC_GET: u32 = 1;
pub const _GLIBCXX_HAVE_TLS: u32 = 1;
pub const _GLIBCXX_HAVE_TRUNCATE: u32 = 1;
pub const _GLIBCXX_HAVE_UCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_UNISTD_H: u32 = 1;
pub const _GLIBCXX_HAVE_UTIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_VFWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VSWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_WCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_WCSTOF: u32 = 1;
pub const _GLIBCXX_HAVE_WCTYPE_H: u32 = 1;
pub const _GLIBCXX_HAVE_WRITEV: u32 = 1;
pub const _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL: u32 = 1;
pub const LT_OBJDIR: &'static [u8; 7usize] = b".libs/\0";
pub const _GLIBCXX_PACKAGE_BUGREPORT: &'static [u8; 1usize] = b"\0";
pub const _GLIBCXX_PACKAGE_NAME: &'static [u8; 15usize] = b"package-unused\0";
pub const _GLIBCXX_PACKAGE_STRING: &'static [u8; 30usize] = b"package-unused version-unused\0";
pub const _GLIBCXX_PACKAGE_TARNAME: &'static [u8; 10usize] = b"libstdc++\0";
pub const _GLIBCXX_PACKAGE_URL: &'static [u8; 1usize] = b"\0";
pub const _GLIBCXX_PACKAGE__GLIBCXX_VERSION: &'static [u8; 15usize] = b"version-unused\0";
pub const STDC_HEADERS: u32 = 1;
pub const _GLIBCXX_DARWIN_USE_64_BIT_INODE: u32 = 1;
pub const _GLIBCXX_FILE_OFFSET_BITS: u32 = 64;
pub const _GLIBCXX11_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX11_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX11_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX98_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX98_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX98_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX_ATOMIC_BUILTINS: u32 = 1;
pub const _GLIBCXX_FULLY_DYNAMIC_STRING: u32 = 0;
pub const _GLIBCXX_HAS_GTHREADS: u32 = 1;
pub const _GLIBCXX_HOSTED: u32 = 1;
pub const _GLIBCXX_PTRDIFF_T_IS_INT: u32 = 1;
pub const _GLIBCXX_RES_LIMITS: u32 = 1;
pub const _GLIBCXX_SIZE_T_IS_UINT: u32 = 1;
pub const _GLIBCXX_STDIO_EOF: i32 = -1;
pub const _GLIBCXX_STDIO_SEEK_CUR: u32 = 1;
pub const _GLIBCXX_STDIO_SEEK_END: u32 = 2;
pub const _GLIBCXX_SYMVER: u32 = 1;
pub const _GLIBCXX_SYMVER_GNU: u32 = 1;
pub const _GLIBCXX_USE_C11_UCHAR_CXX11: u32 = 1;
pub const _GLIBCXX_USE_C99: u32 = 1;
pub const _GLIBCXX_USE_C99_COMPLEX_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_CTYPE_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_FENV_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_MATH_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_STDINT_TR1: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_MONOTONIC: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_REALTIME: u32 = 1;
pub const _GLIBCXX_USE_DECIMAL_FLOAT: u32 = 1;
pub const _GLIBCXX_USE_DEV_RANDOM: u32 = 1;
pub const _GLIBCXX_USE_FCHMOD: u32 = 1;
pub const _GLIBCXX_USE_FCHMODAT: u32 = 1;
pub const _GLIBCXX_USE_GETTIMEOFDAY: u32 = 1;
pub const _GLIBCXX_USE_GET_NPROCS: u32 = 1;
pub const _GLIBCXX_USE_LFS: u32 = 1;
pub const _GLIBCXX_USE_LONG_LONG: u32 = 1;
pub const _GLIBCXX_USE_LSTAT: u32 = 1;
pub const _GLIBCXX_USE_NANOSLEEP: u32 = 1;
pub const _GLIBCXX_USE_NLS: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_MUTEX_CLOCKLOCK: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_RWLOCK_CLOCKLOCK: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_RWLOCK_T: u32 = 1;
pub const _GLIBCXX_USE_RANDOM_TR1: u32 = 1;
pub const _GLIBCXX_USE_REALPATH: u32 = 1;
pub const _GLIBCXX_USE_SCHED_YIELD: u32 = 1;
pub const _GLIBCXX_USE_SC_NPROCESSORS_ONLN: u32 = 1;
pub const _GLIBCXX_USE_SENDFILE: u32 = 1;
pub const _GLIBCXX_USE_ST_MTIM: u32 = 1;
pub const _GLIBCXX_USE_TMPNAM: u32 = 1;
pub const _GLIBCXX_USE_UTIME: u32 = 1;
pub const _GLIBCXX_USE_UTIMENSAT: u32 = 1;
pub const _GLIBCXX_USE_WCHAR_T: u32 = 1;
pub const _GLIBCXX_VERBOSE: u32 = 1;
pub const _GLIBCXX_X86_RDRAND: u32 = 1;
pub const _GLIBCXX_X86_RDSEED: u32 = 1;
pub const _GTHREAD_USE_MUTEX_TIMEDLOCK: u32 = 1;
pub const _ASSERT_H: u32 = 1;
pub const PARAM_ASSERTIONS_ENABLE_ALL: u32 = 0;
pub const PARAM_ASSERTIONS_DISABLE_ALL: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 32;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 0;
pub const __STATFS_MATCHES_STATFS64: u32 = 0;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 0;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INT8_WIDTH: u32 = 8;
pub const UINT8_WIDTH: u32 = 8;
pub const INT16_WIDTH: u32 = 16;
pub const UINT16_WIDTH: u32 = 16;
pub const INT32_WIDTH: u32 = 32;
pub const UINT32_WIDTH: u32 = 32;
pub const INT64_WIDTH: u32 = 64;
pub const UINT64_WIDTH: u32 = 64;
pub const INT_LEAST8_WIDTH: u32 = 8;
pub const UINT_LEAST8_WIDTH: u32 = 8;
pub const INT_LEAST16_WIDTH: u32 = 16;
pub const UINT_LEAST16_WIDTH: u32 = 16;
pub const INT_LEAST32_WIDTH: u32 = 32;
pub const UINT_LEAST32_WIDTH: u32 = 32;
pub const INT_LEAST64_WIDTH: u32 = 64;
pub const UINT_LEAST64_WIDTH: u32 = 64;
pub const INT_FAST8_WIDTH: u32 = 8;
pub const UINT_FAST8_WIDTH: u32 = 8;
pub const INT_FAST16_WIDTH: u32 = 32;
pub const UINT_FAST16_WIDTH: u32 = 32;
pub const INT_FAST32_WIDTH: u32 = 32;
pub const UINT_FAST32_WIDTH: u32 = 32;
pub const INT_FAST64_WIDTH: u32 = 64;
pub const UINT_FAST64_WIDTH: u32 = 64;
pub const INTPTR_WIDTH: u32 = 32;
pub const UINTPTR_WIDTH: u32 = 32;
pub const INTMAX_WIDTH: u32 = 64;
pub const UINTMAX_WIDTH: u32 = 64;
pub const PTRDIFF_WIDTH: u32 = 32;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const SIZE_WIDTH: u32 = 32;
pub const WCHAR_WIDTH: u32 = 32;
pub const WINT_WIDTH: u32 = 32;
pub const PICO_SDK_VERSION_MAJOR: u32 = 1;
pub const PICO_SDK_VERSION_MINOR: u32 = 2;
pub const PICO_SDK_VERSION_REVISION: u32 = 0;
pub const PICO_SDK_VERSION_STRING: &'static [u8; 6usize] = b"1.2.0\0";
pub const PICO_NO_RAM_VECTOR_TABLE: u32 = 0;
pub const PICO_NO_FPGA_CHECK: u32 = 0;
pub const PICO_STDOUT_MUTEX: u32 = 1;
pub const PICO_STDIO_ENABLE_CRLF_SUPPORT: u32 = 1;
pub const PICO_STDIO_DEFAULT_CRLF: u32 = 1;
pub const PICO_STDIO_STACK_BUFFER_SIZE: u32 = 128;
pub const REG_ALIAS_RW_BITS: u32 = 0;
pub const REG_ALIAS_XOR_BITS: u32 = 4096;
pub const REG_ALIAS_SET_BITS: u32 = 8192;
pub const REG_ALIAS_CLR_BITS: u32 = 12288;
pub const TIMER_TIMEHW_ACCESS: &'static [u8; 3usize] = b"WF\0";
pub const TIMER_TIMELW_ACCESS: &'static [u8; 3usize] = b"WF\0";
pub const TIMER_TIMEHR_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const TIMER_TIMELR_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const TIMER_ALARM0_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const TIMER_ALARM1_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const TIMER_ALARM2_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const TIMER_ALARM3_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const TIMER_ARMED_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const TIMER_TIMERAWH_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const TIMER_TIMERAWL_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const TIMER_DBGPAUSE_DBG1_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const TIMER_DBGPAUSE_DBG0_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const TIMER_PAUSE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const TIMER_INTR_ALARM_3_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const TIMER_INTR_ALARM_2_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const TIMER_INTR_ALARM_1_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const TIMER_INTR_ALARM_0_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const TIMER_INTE_ALARM_3_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const TIMER_INTE_ALARM_2_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const TIMER_INTE_ALARM_1_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const TIMER_INTE_ALARM_0_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const TIMER_INTF_ALARM_3_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const TIMER_INTF_ALARM_2_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const TIMER_INTF_ALARM_1_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const TIMER_INTF_ALARM_0_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const TIMER_INTS_ALARM_3_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const TIMER_INTS_ALARM_2_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const TIMER_INTS_ALARM_1_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const TIMER_INTS_ALARM_0_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const NUM_TIMERS: u32 = 4;
pub const PARAM_ASSERTIONS_ENABLED_TIMER: u32 = 0;
pub const PARAM_ASSERTIONS_ENABLED_TIME: u32 = 0;
pub const PICO_TIME_SLEEP_OVERHEAD_ADJUST_US: u32 = 6;
pub const PICO_TIME_DEFAULT_ALARM_POOL_DISABLED: u32 = 0;
pub const PICO_TIME_DEFAULT_ALARM_POOL_HARDWARE_ALARM_NUM: u32 = 3;
pub const PICO_TIME_DEFAULT_ALARM_POOL_MAX_TIMERS: u32 = 16;
pub const SIO_CPUID_RESET: &'static [u8; 2usize] = b"-\0";
pub const SIO_CPUID_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_GPIO_IN_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_GPIO_HI_IN_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_GPIO_OUT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_GPIO_OUT_SET_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_GPIO_OUT_CLR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_GPIO_OUT_XOR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_GPIO_OE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_GPIO_OE_SET_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_GPIO_OE_CLR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_GPIO_OE_XOR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_GPIO_HI_OUT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_GPIO_HI_OUT_SET_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_GPIO_HI_OUT_CLR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_GPIO_HI_OUT_XOR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_GPIO_HI_OE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_GPIO_HI_OE_SET_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_GPIO_HI_OE_CLR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_GPIO_HI_OE_XOR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_FIFO_ST_ROE_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const SIO_FIFO_ST_WOF_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const SIO_FIFO_ST_RDY_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_FIFO_ST_VLD_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_FIFO_WR_ACCESS: &'static [u8; 3usize] = b"WF\0";
pub const SIO_FIFO_RD_RESET: &'static [u8; 2usize] = b"-\0";
pub const SIO_FIFO_RD_ACCESS: &'static [u8; 3usize] = b"RF\0";
pub const SIO_SPINLOCK_ST_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_DIV_UDIVIDEND_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_DIV_UDIVISOR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_DIV_SDIVIDEND_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_DIV_SDIVISOR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_DIV_QUOTIENT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_DIV_REMAINDER_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_DIV_CSR_DIRTY_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_DIV_CSR_READY_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_INTERP0_ACCUM0_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_ACCUM1_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_BASE0_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_BASE1_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_BASE2_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_POP_LANE0_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_INTERP0_POP_LANE1_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_INTERP0_POP_FULL_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_INTERP0_PEEK_LANE0_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_INTERP0_PEEK_LANE1_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_INTERP0_PEEK_FULL_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_INTERP0_CTRL_LANE0_OVERF_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_INTERP0_CTRL_LANE0_OVERF1_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_INTERP0_CTRL_LANE0_OVERF0_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_INTERP0_CTRL_LANE0_BLEND_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_FORCE_MSB_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_ADD_RAW_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_CROSS_RESULT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_CROSS_INPUT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_SIGNED_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_MASK_MSB_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_MASK_LSB_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE0_SHIFT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_FORCE_MSB_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_ADD_RAW_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_CROSS_RESULT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_CROSS_INPUT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_SIGNED_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_MASK_MSB_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_MASK_LSB_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_CTRL_LANE1_SHIFT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_ACCUM0_ADD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_ACCUM1_ADD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP0_BASE_1AND0_ACCESS: &'static [u8; 3usize] = b"WO\0";
pub const SIO_INTERP1_ACCUM0_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_ACCUM1_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_BASE0_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_BASE1_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_BASE2_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_POP_LANE0_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_INTERP1_POP_LANE1_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_INTERP1_POP_FULL_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_INTERP1_PEEK_LANE0_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_INTERP1_PEEK_LANE1_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_INTERP1_PEEK_FULL_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_INTERP1_CTRL_LANE0_OVERF_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_INTERP1_CTRL_LANE0_OVERF1_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_INTERP1_CTRL_LANE0_OVERF0_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_INTERP1_CTRL_LANE0_CLAMP_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_FORCE_MSB_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_ADD_RAW_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_CROSS_RESULT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_CROSS_INPUT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_SIGNED_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_MASK_MSB_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_MASK_LSB_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE0_SHIFT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_FORCE_MSB_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_ADD_RAW_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_CROSS_RESULT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_CROSS_INPUT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_SIGNED_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_MASK_MSB_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_MASK_LSB_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_CTRL_LANE1_SHIFT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_ACCUM0_ADD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_ACCUM1_ADD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const SIO_INTERP1_BASE_1AND0_ACCESS: &'static [u8; 3usize] = b"WO\0";
pub const SIO_SPINLOCK0_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK1_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK2_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK3_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK4_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK5_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK6_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK7_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK8_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK9_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK10_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK11_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK12_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK13_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK14_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK15_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK16_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK17_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK18_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK19_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK20_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK21_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK22_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK23_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK24_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK25_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK26_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK27_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK28_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK29_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK30_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const SIO_SPINLOCK31_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const PADS_BANK0_VOLTAGE_SELECT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO0_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO0_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO0_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO0_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO0_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO0_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO0_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO1_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO1_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO1_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO1_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO1_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO1_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO1_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO2_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO2_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO2_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO2_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO2_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO2_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO2_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO3_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO3_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO3_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO3_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO3_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO3_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO3_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO4_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO4_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO4_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO4_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO4_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO4_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO4_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO5_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO5_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO5_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO5_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO5_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO5_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO5_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO6_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO6_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO6_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO6_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO6_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO6_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO6_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO7_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO7_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO7_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO7_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO7_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO7_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO7_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO8_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO8_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO8_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO8_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO8_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO8_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO8_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO9_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO9_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO9_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO9_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO9_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO9_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO9_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO10_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO10_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO10_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO10_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO10_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO10_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO10_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO11_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO11_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO11_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO11_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO11_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO11_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO11_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO12_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO12_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO12_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO12_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO12_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO12_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO12_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO13_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO13_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO13_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO13_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO13_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO13_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO13_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO14_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO14_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO14_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO14_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO14_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO14_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO14_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO15_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO15_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO15_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO15_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO15_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO15_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO15_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO16_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO16_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO16_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO16_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO16_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO16_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO16_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO17_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO17_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO17_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO17_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO17_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO17_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO17_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO18_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO18_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO18_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO18_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO18_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO18_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO18_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO19_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO19_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO19_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO19_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO19_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO19_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO19_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO20_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO20_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO20_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO20_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO20_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO20_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO20_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO21_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO21_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO21_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO21_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO21_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO21_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO21_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO22_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO22_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO22_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO22_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO22_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO22_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO22_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO23_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO23_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO23_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO23_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO23_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO23_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO23_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO24_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO24_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO24_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO24_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO24_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO24_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO24_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO25_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO25_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO25_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO25_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO25_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO25_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO25_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO26_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO26_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO26_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO26_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO26_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO26_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO26_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO27_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO27_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO27_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO27_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO27_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO27_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO27_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO28_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO28_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO28_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO28_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO28_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO28_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO28_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO29_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO29_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO29_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO29_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO29_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO29_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_GPIO29_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWCLK_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWCLK_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWCLK_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWCLK_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWCLK_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWCLK_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWCLK_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWD_OD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWD_IE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWD_DRIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWD_PUE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWD_PDE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWD_SCHMITT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PADS_BANK0_SWD_SLEWFAST_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PARAM_ASSERTIONS_ENABLED_GPIO: u32 = 0;
pub const GPIO_OUT: u32 = 1;
pub const GPIO_IN: u32 = 0;
pub const PICO_DEBUG_PIN_BASE: u32 = 19;
pub const PICO_DEBUG_PIN_COUNT: u32 = 3;
pub const UART_UARTDR_OE_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTDR_OE_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTDR_BE_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTDR_BE_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTDR_PE_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTDR_PE_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTDR_FE_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTDR_FE_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTDR_DATA_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTDR_DATA_ACCESS: &'static [u8; 4usize] = b"RWF\0";
pub const UART_UARTRSR_OE_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const UART_UARTRSR_BE_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const UART_UARTRSR_PE_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const UART_UARTRSR_FE_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const UART_UARTFR_RI_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTFR_RI_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTFR_TXFE_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTFR_RXFF_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTFR_TXFF_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTFR_RXFE_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTFR_BUSY_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTFR_DCD_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTFR_DCD_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTFR_DSR_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTFR_DSR_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTFR_CTS_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTFR_CTS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTILPR_ILPDVSR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTIBRD_BAUD_DIVINT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTFBRD_BAUD_DIVFRAC_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTLCR_H_SPS_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTLCR_H_WLEN_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTLCR_H_FEN_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTLCR_H_STP2_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTLCR_H_EPS_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTLCR_H_PEN_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTLCR_H_BRK_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTCR_CTSEN_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTCR_RTSEN_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTCR_OUT2_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTCR_OUT1_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTCR_RTS_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTCR_DTR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTCR_RXE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTCR_TXE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTCR_LBE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTCR_SIRLP_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTCR_SIREN_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTCR_UARTEN_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTIFLS_RXIFLSEL_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTIFLS_TXIFLSEL_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTIMSC_OEIM_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTIMSC_BEIM_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTIMSC_PEIM_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTIMSC_FEIM_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTIMSC_RTIM_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTIMSC_TXIM_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTIMSC_RXIM_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTIMSC_DSRMIM_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTIMSC_DCDMIM_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTIMSC_CTSMIM_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTIMSC_RIMIM_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTRIS_OERIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTRIS_BERIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTRIS_PERIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTRIS_FERIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTRIS_RTRIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTRIS_TXRIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTRIS_RXRIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTRIS_DSRRMIS_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTRIS_DSRRMIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTRIS_DCDRMIS_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTRIS_DCDRMIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTRIS_CTSRMIS_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTRIS_CTSRMIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTRIS_RIRMIS_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTRIS_RIRMIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTMIS_OEMIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTMIS_BEMIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTMIS_PEMIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTMIS_FEMIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTMIS_RTMIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTMIS_TXMIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTMIS_RXMIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTMIS_DSRMMIS_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTMIS_DSRMMIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTMIS_DCDMMIS_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTMIS_DCDMMIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTMIS_CTSMMIS_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTMIS_CTSMMIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTMIS_RIMMIS_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTMIS_RIMMIS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTICR_OEIC_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTICR_OEIC_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const UART_UARTICR_BEIC_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTICR_BEIC_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const UART_UARTICR_PEIC_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTICR_PEIC_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const UART_UARTICR_FEIC_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTICR_FEIC_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const UART_UARTICR_RTIC_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTICR_RTIC_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const UART_UARTICR_TXIC_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTICR_TXIC_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const UART_UARTICR_RXIC_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTICR_RXIC_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const UART_UARTICR_DSRMIC_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTICR_DSRMIC_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const UART_UARTICR_DCDMIC_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTICR_DCDMIC_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const UART_UARTICR_CTSMIC_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTICR_CTSMIC_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const UART_UARTICR_RIMIC_RESET: &'static [u8; 2usize] = b"-\0";
pub const UART_UARTICR_RIMIC_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const UART_UARTDMACR_DMAONERR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTDMACR_TXDMAE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTDMACR_RXDMAE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const UART_UARTPERIPHID0_PARTNUMBER0_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTPERIPHID1_DESIGNER0_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTPERIPHID1_PARTNUMBER1_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTPERIPHID2_REVISION_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTPERIPHID2_DESIGNER1_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTPERIPHID3_CONFIGURATION_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTPCELLID0_UARTPCELLID0_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTPCELLID1_UARTPCELLID1_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTPCELLID2_UARTPCELLID2_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const UART_UARTPCELLID3_UARTPCELLID3_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const PARAM_ASSERTIONS_ENABLED_UART: u32 = 0;
pub const PICO_UART_ENABLE_CRLF_SUPPORT: u32 = 1;
pub const PICO_UART_DEFAULT_CRLF: u32 = 0;
pub const PICO_DEFAULT_UART_BAUD_RATE: u32 = 115200;
pub const PICO_DEFAULT_LED_PIN_INVERTED: u32 = 0;
pub const PARAM_ASSERTIONS_ENABLED_SYNC: u32 = 0;
pub const PICO_SPINLOCK_ID_IRQ: u32 = 9;
pub const PICO_SPINLOCK_ID_TIMER: u32 = 10;
pub const PICO_SPINLOCK_ID_HARDWARE_CLAIM: u32 = 11;
pub const PICO_SPINLOCK_ID_OS1: u32 = 14;
pub const PICO_SPINLOCK_ID_OS2: u32 = 15;
pub const PICO_SPINLOCK_ID_STRIPED_FIRST: u32 = 16;
pub const PICO_SPINLOCK_ID_STRIPED_LAST: u32 = 23;
pub const PICO_SPINLOCK_ID_CLAIM_FREE_FIRST: u32 = 24;
pub const PICO_SPINLOCK_ID_CLAIM_FREE_LAST: u32 = 31;
pub const PICO_MAX_SHARED_IRQ_HANDLERS: u32 = 4;
pub const PICO_DISABLE_SHARED_IRQ_HANDLERS: u32 = 0;
pub const TIMER_IRQ_0: u32 = 0;
pub const TIMER_IRQ_1: u32 = 1;
pub const TIMER_IRQ_2: u32 = 2;
pub const TIMER_IRQ_3: u32 = 3;
pub const PWM_IRQ_WRAP: u32 = 4;
pub const USBCTRL_IRQ: u32 = 5;
pub const XIP_IRQ: u32 = 6;
pub const PIO0_IRQ_0: u32 = 7;
pub const PIO0_IRQ_1: u32 = 8;
pub const PIO1_IRQ_0: u32 = 9;
pub const PIO1_IRQ_1: u32 = 10;
pub const DMA_IRQ_0: u32 = 11;
pub const DMA_IRQ_1: u32 = 12;
pub const IO_IRQ_BANK0: u32 = 13;
pub const IO_IRQ_QSPI: u32 = 14;
pub const SIO_IRQ_PROC0: u32 = 15;
pub const SIO_IRQ_PROC1: u32 = 16;
pub const CLOCKS_IRQ: u32 = 17;
pub const SPI0_IRQ: u32 = 18;
pub const SPI1_IRQ: u32 = 19;
pub const UART0_IRQ: u32 = 20;
pub const UART1_IRQ: u32 = 21;
pub const ADC_IRQ_FIFO: u32 = 22;
pub const I2C0_IRQ: u32 = 23;
pub const I2C1_IRQ: u32 = 24;
pub const RTC_IRQ: u32 = 25;
pub const M0PLUS_SYST_CSR_COUNTFLAG_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const M0PLUS_SYST_CSR_CLKSOURCE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_SYST_CSR_TICKINT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_SYST_CSR_ENABLE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_SYST_RVR_RELOAD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_SYST_CVR_CURRENT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_SYST_CALIB_NOREF_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const M0PLUS_SYST_CALIB_SKEW_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const M0PLUS_SYST_CALIB_TENMS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const M0PLUS_NVIC_ISER_SETENA_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_ICER_CLRENA_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_ISPR_SETPEND_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_ICPR_CLRPEND_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR0_IP_3_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR0_IP_2_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR0_IP_1_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR0_IP_0_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR1_IP_7_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR1_IP_6_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR1_IP_5_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR1_IP_4_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR2_IP_11_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR2_IP_10_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR2_IP_9_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR2_IP_8_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR3_IP_15_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR3_IP_14_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR3_IP_13_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR3_IP_12_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR4_IP_19_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR4_IP_18_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR4_IP_17_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR4_IP_16_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR5_IP_23_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR5_IP_22_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR5_IP_21_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR5_IP_20_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR6_IP_27_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR6_IP_26_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR6_IP_25_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR6_IP_24_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR7_IP_31_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR7_IP_30_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR7_IP_29_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_NVIC_IPR7_IP_28_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_CPUID_IMPLEMENTER_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const M0PLUS_CPUID_VARIANT_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const M0PLUS_CPUID_ARCHITECTURE_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const M0PLUS_CPUID_PARTNO_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const M0PLUS_CPUID_REVISION_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const M0PLUS_ICSR_NMIPENDSET_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_ICSR_PENDSVSET_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_ICSR_PENDSVCLR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_ICSR_PENDSTSET_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_ICSR_PENDSTCLR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_ICSR_ISRPREEMPT_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const M0PLUS_ICSR_ISRPENDING_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const M0PLUS_ICSR_VECTPENDING_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const M0PLUS_ICSR_VECTACTIVE_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const M0PLUS_VTOR_TBLOFF_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_AIRCR_VECTKEY_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_AIRCR_ENDIANESS_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const M0PLUS_AIRCR_SYSRESETREQ_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_AIRCR_VECTCLRACTIVE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_SCR_SEVONPEND_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_SCR_SLEEPDEEP_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_SCR_SLEEPONEXIT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_CCR_STKALIGN_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const M0PLUS_CCR_UNALIGN_TRP_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const M0PLUS_SHPR2_PRI_11_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_SHPR3_PRI_15_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_SHPR3_PRI_14_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_SHCSR_SVCALLPENDED_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_TYPE_IREGION_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const M0PLUS_MPU_TYPE_DREGION_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const M0PLUS_MPU_TYPE_SEPARATE_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const M0PLUS_MPU_CTRL_PRIVDEFENA_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_CTRL_HFNMIENA_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_CTRL_ENABLE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_RNR_REGION_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_RBAR_ADDR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_RBAR_VALID_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_RBAR_REGION_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_RASR_ATTRS_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_RASR_SRD_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_RASR_SIZE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const M0PLUS_MPU_RASR_ENABLE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PICO_DEFAULT_IRQ_PRIORITY: u32 = 128;
pub const PICO_LOWEST_IRQ_PRIORITY: u32 = 255;
pub const PICO_HIGHEST_IRQ_PRIORITY: u32 = 0;
pub const PICO_SHARED_IRQ_HANDLER_DEFAULT_ORDER_PRIORITY: u32 = 128;
pub const PARAM_ASSERTIONS_ENABLED_IRQ: u32 = 0;
pub const RTC_CLKDIV_M1_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_SETUP_0_YEAR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_SETUP_0_MONTH_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_SETUP_0_DAY_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_SETUP_1_DOTW_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_SETUP_1_HOUR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_SETUP_1_MIN_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_SETUP_1_SEC_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_CTRL_FORCE_NOTLEAPYEAR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_CTRL_LOAD_ACCESS: &'static [u8; 3usize] = b"SC\0";
pub const RTC_CTRL_RTC_ACTIVE_RESET: &'static [u8; 2usize] = b"-\0";
pub const RTC_CTRL_RTC_ACTIVE_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const RTC_CTRL_RTC_ENABLE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_IRQ_SETUP_0_MATCH_ACTIVE_RESET: &'static [u8; 2usize] = b"-\0";
pub const RTC_IRQ_SETUP_0_MATCH_ACTIVE_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const RTC_IRQ_SETUP_0_MATCH_ENA_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_IRQ_SETUP_0_YEAR_ENA_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_IRQ_SETUP_0_MONTH_ENA_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_IRQ_SETUP_0_DAY_ENA_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_IRQ_SETUP_0_YEAR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_IRQ_SETUP_0_MONTH_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_IRQ_SETUP_0_DAY_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_IRQ_SETUP_1_DOTW_ENA_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_IRQ_SETUP_1_HOUR_ENA_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_IRQ_SETUP_1_MIN_ENA_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_IRQ_SETUP_1_SEC_ENA_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_IRQ_SETUP_1_DOTW_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_IRQ_SETUP_1_HOUR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_IRQ_SETUP_1_MIN_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_IRQ_SETUP_1_SEC_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_RTC_1_YEAR_RESET: &'static [u8; 2usize] = b"-\0";
pub const RTC_RTC_1_YEAR_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const RTC_RTC_1_MONTH_RESET: &'static [u8; 2usize] = b"-\0";
pub const RTC_RTC_1_MONTH_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const RTC_RTC_1_DAY_RESET: &'static [u8; 2usize] = b"-\0";
pub const RTC_RTC_1_DAY_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const RTC_RTC_0_DOTW_RESET: &'static [u8; 2usize] = b"-\0";
pub const RTC_RTC_0_DOTW_ACCESS: &'static [u8; 3usize] = b"RF\0";
pub const RTC_RTC_0_HOUR_RESET: &'static [u8; 2usize] = b"-\0";
pub const RTC_RTC_0_HOUR_ACCESS: &'static [u8; 3usize] = b"RF\0";
pub const RTC_RTC_0_MIN_RESET: &'static [u8; 2usize] = b"-\0";
pub const RTC_RTC_0_MIN_ACCESS: &'static [u8; 3usize] = b"RF\0";
pub const RTC_RTC_0_SEC_RESET: &'static [u8; 2usize] = b"-\0";
pub const RTC_RTC_0_SEC_ACCESS: &'static [u8; 3usize] = b"RF\0";
pub const RTC_INTR_RTC_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const RTC_INTE_RTC_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_INTF_RTC_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const RTC_INTS_RTC_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const PWM_CH0_CSR_PH_ADV_ACCESS: &'static [u8; 3usize] = b"SC\0";
pub const PWM_CH0_CSR_PH_RET_ACCESS: &'static [u8; 3usize] = b"SC\0";
pub const PWM_CH0_CSR_DIVMODE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH0_CSR_B_INV_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH0_CSR_A_INV_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH0_CSR_PH_CORRECT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH0_CSR_EN_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH0_DIV_INT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH0_DIV_FRAC_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH0_CTR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH0_CC_B_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH0_CC_A_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH0_TOP_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH1_CSR_PH_ADV_ACCESS: &'static [u8; 3usize] = b"SC\0";
pub const PWM_CH1_CSR_PH_RET_ACCESS: &'static [u8; 3usize] = b"SC\0";
pub const PWM_CH1_CSR_DIVMODE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH1_CSR_B_INV_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH1_CSR_A_INV_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH1_CSR_PH_CORRECT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH1_CSR_EN_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH1_DIV_INT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH1_DIV_FRAC_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH1_CTR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH1_CC_B_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH1_CC_A_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH1_TOP_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH2_CSR_PH_ADV_ACCESS: &'static [u8; 3usize] = b"SC\0";
pub const PWM_CH2_CSR_PH_RET_ACCESS: &'static [u8; 3usize] = b"SC\0";
pub const PWM_CH2_CSR_DIVMODE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH2_CSR_B_INV_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH2_CSR_A_INV_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH2_CSR_PH_CORRECT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH2_CSR_EN_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH2_DIV_INT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH2_DIV_FRAC_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH2_CTR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH2_CC_B_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH2_CC_A_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH2_TOP_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH3_CSR_PH_ADV_ACCESS: &'static [u8; 3usize] = b"SC\0";
pub const PWM_CH3_CSR_PH_RET_ACCESS: &'static [u8; 3usize] = b"SC\0";
pub const PWM_CH3_CSR_DIVMODE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH3_CSR_B_INV_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH3_CSR_A_INV_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH3_CSR_PH_CORRECT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH3_CSR_EN_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH3_DIV_INT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH3_DIV_FRAC_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH3_CTR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH3_CC_B_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH3_CC_A_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH3_TOP_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH4_CSR_PH_ADV_ACCESS: &'static [u8; 3usize] = b"SC\0";
pub const PWM_CH4_CSR_PH_RET_ACCESS: &'static [u8; 3usize] = b"SC\0";
pub const PWM_CH4_CSR_DIVMODE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH4_CSR_B_INV_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH4_CSR_A_INV_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH4_CSR_PH_CORRECT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH4_CSR_EN_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH4_DIV_INT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH4_DIV_FRAC_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH4_CTR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH4_CC_B_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH4_CC_A_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH4_TOP_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH5_CSR_PH_ADV_ACCESS: &'static [u8; 3usize] = b"SC\0";
pub const PWM_CH5_CSR_PH_RET_ACCESS: &'static [u8; 3usize] = b"SC\0";
pub const PWM_CH5_CSR_DIVMODE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH5_CSR_B_INV_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH5_CSR_A_INV_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH5_CSR_PH_CORRECT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH5_CSR_EN_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH5_DIV_INT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH5_DIV_FRAC_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH5_CTR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH5_CC_B_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH5_CC_A_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH5_TOP_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH6_CSR_PH_ADV_ACCESS: &'static [u8; 3usize] = b"SC\0";
pub const PWM_CH6_CSR_PH_RET_ACCESS: &'static [u8; 3usize] = b"SC\0";
pub const PWM_CH6_CSR_DIVMODE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH6_CSR_B_INV_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH6_CSR_A_INV_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH6_CSR_PH_CORRECT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH6_CSR_EN_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH6_DIV_INT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH6_DIV_FRAC_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH6_CTR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH6_CC_B_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH6_CC_A_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH6_TOP_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH7_CSR_PH_ADV_ACCESS: &'static [u8; 3usize] = b"SC\0";
pub const PWM_CH7_CSR_PH_RET_ACCESS: &'static [u8; 3usize] = b"SC\0";
pub const PWM_CH7_CSR_DIVMODE_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH7_CSR_B_INV_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH7_CSR_A_INV_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH7_CSR_PH_CORRECT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH7_CSR_EN_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH7_DIV_INT_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH7_DIV_FRAC_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH7_CTR_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH7_CC_B_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH7_CC_A_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_CH7_TOP_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_EN_CH7_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_EN_CH6_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_EN_CH5_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_EN_CH4_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_EN_CH3_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_EN_CH2_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_EN_CH1_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_EN_CH0_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_INTR_CH7_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const PWM_INTR_CH6_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const PWM_INTR_CH5_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const PWM_INTR_CH4_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const PWM_INTR_CH3_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const PWM_INTR_CH2_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const PWM_INTR_CH1_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const PWM_INTR_CH0_ACCESS: &'static [u8; 3usize] = b"WC\0";
pub const PWM_INTE_CH7_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_INTE_CH6_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_INTE_CH5_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_INTE_CH4_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_INTE_CH3_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_INTE_CH2_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_INTE_CH1_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_INTE_CH0_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_INTF_CH7_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_INTF_CH6_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_INTF_CH5_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_INTF_CH4_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_INTF_CH3_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_INTF_CH2_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_INTF_CH1_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_INTF_CH0_ACCESS: &'static [u8; 3usize] = b"RW\0";
pub const PWM_INTS_CH7_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const PWM_INTS_CH6_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const PWM_INTS_CH5_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const PWM_INTS_CH4_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const PWM_INTS_CH3_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const PWM_INTS_CH2_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const PWM_INTS_CH1_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const PWM_INTS_CH0_ACCESS: &'static [u8; 3usize] = b"RO\0";
pub const PARAM_ASSERTIONS_ENABLED_PWM: u32 = 0;
pub type std_size_t = crate::ctypes::c_uint;
pub type std_nullptr_t = *const crate::ctypes::c_void;
extern "C" {
    pub fn __assert_fail(
        __assertion: *const crate::ctypes::c_char,
        __file: *const crate::ctypes::c_char,
        __line: crate::ctypes::c_uint,
        __function: *const crate::ctypes::c_char,
    );
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: crate::ctypes::c_int,
        __file: *const crate::ctypes::c_char,
        __line: crate::ctypes::c_uint,
        __function: *const crate::ctypes::c_char,
    );
}
extern "C" {
    pub fn __assert(
        __assertion: *const crate::ctypes::c_char,
        __file: *const crate::ctypes::c_char,
        __line: crate::ctypes::c_int,
    );
}
pub type __u_char = crate::ctypes::c_uchar;
pub type __u_short = crate::ctypes::c_ushort;
pub type __u_int = crate::ctypes::c_uint;
pub type __u_long = crate::ctypes::c_ulong;
pub type __int8_t = crate::ctypes::c_schar;
pub type __uint8_t = crate::ctypes::c_uchar;
pub type __int16_t = crate::ctypes::c_short;
pub type __uint16_t = crate::ctypes::c_ushort;
pub type __int32_t = crate::ctypes::c_int;
pub type __uint32_t = crate::ctypes::c_uint;
pub type __int64_t = crate::ctypes::c_longlong;
pub type __uint64_t = crate::ctypes::c_ulonglong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = crate::ctypes::c_longlong;
pub type __u_quad_t = crate::ctypes::c_ulonglong;
pub type __intmax_t = crate::ctypes::c_longlong;
pub type __uintmax_t = crate::ctypes::c_ulonglong;
pub type __dev_t = __uint64_t;
pub type __uid_t = crate::ctypes::c_uint;
pub type __gid_t = crate::ctypes::c_uint;
pub type __ino_t = crate::ctypes::c_ulong;
pub type __ino64_t = __uint64_t;
pub type __mode_t = crate::ctypes::c_uint;
pub type __nlink_t = crate::ctypes::c_uint;
pub type __off_t = crate::ctypes::c_long;
pub type __off64_t = __int64_t;
pub type __pid_t = crate::ctypes::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [crate::ctypes::c_int; 2usize],
}
pub type __clock_t = crate::ctypes::c_long;
pub type __rlim_t = crate::ctypes::c_ulong;
pub type __rlim64_t = __uint64_t;
pub type __id_t = crate::ctypes::c_uint;
pub type __time_t = crate::ctypes::c_long;
pub type __useconds_t = crate::ctypes::c_uint;
pub type __suseconds_t = crate::ctypes::c_long;
pub type __suseconds64_t = __int64_t;
pub type __daddr_t = crate::ctypes::c_int;
pub type __key_t = crate::ctypes::c_int;
pub type __clockid_t = crate::ctypes::c_int;
pub type __timer_t = *mut crate::ctypes::c_void;
pub type __blksize_t = crate::ctypes::c_long;
pub type __blkcnt_t = crate::ctypes::c_long;
pub type __blkcnt64_t = __int64_t;
pub type __fsblkcnt_t = crate::ctypes::c_ulong;
pub type __fsblkcnt64_t = __uint64_t;
pub type __fsfilcnt_t = crate::ctypes::c_ulong;
pub type __fsfilcnt64_t = __uint64_t;
pub type __fsword_t = crate::ctypes::c_int;
pub type __ssize_t = crate::ctypes::c_int;
pub type __syscall_slong_t = crate::ctypes::c_long;
pub type __syscall_ulong_t = crate::ctypes::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut crate::ctypes::c_char;
pub type __intptr_t = crate::ctypes::c_int;
pub type __socklen_t = crate::ctypes::c_uint;
pub type __sig_atomic_t = crate::ctypes::c_int;
pub type __time64_t = __int64_t;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = crate::ctypes::c_schar;
pub type int_fast16_t = crate::ctypes::c_int;
pub type int_fast32_t = crate::ctypes::c_int;
pub type int_fast64_t = crate::ctypes::c_longlong;
pub type uint_fast8_t = crate::ctypes::c_uchar;
pub type uint_fast16_t = crate::ctypes::c_uint;
pub type uint_fast32_t = crate::ctypes::c_uint;
pub type uint_fast64_t = crate::ctypes::c_ulonglong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type size_t = crate::ctypes::c_uint;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: crate::ctypes::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
pub type uint = crate::ctypes::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct absolute_time_t {
    pub _private_us_since_boot: u64,
}
#[doc = " \\struct datetime_t"]
#[doc = "  \\ingroup util_datetime"]
#[doc = "  \\brief Structure containing date and time information"]
#[doc = ""]
#[doc = "    When setting an RTC alarm, set a field to -1 tells"]
#[doc = "    the RTC to not match on this field"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct datetime_t {
    #[doc = "< 0..4095"]
    pub year: i16,
    #[doc = "< 1..12, 1 is January"]
    pub month: i8,
    #[doc = "< 1..28,29,30,31 depending on month"]
    pub day: i8,
    #[doc = "< 0..6, 0 is Sunday"]
    pub dotw: i8,
    #[doc = "< 0..23"]
    pub hour: i8,
    #[doc = "< 0..59"]
    pub min: i8,
    #[doc = "< 0..59"]
    pub sec: i8,
}
extern "C" {
    #[doc = " Panic (see panic()) with the message \"Unsupported\"."]
    pub fn panic_unsupported();
}
extern "C" {
    #[doc = " Panic with a message. An attempt is made to output the message to all registered STDOUT drivers"]
    #[doc = " after which this method executes a BKPT instruction."]
    #[doc = ""]
    #[doc = " @param fmt format string (printf-like)"]
    #[doc = " @param ...  printf-like arguments"]
    pub fn panic(fmt: *const crate::ctypes::c_char, ...);
}
extern "C" {
    pub fn running_on_fpga() -> bool;
}
extern "C" {
    #[doc = " @return the RP2040 chip revision number"]
    pub fn rp2040_chip_version() -> u8;
}
extern "C" {
    #[doc = " Get the current exception level on this core"]
    #[doc = " \\return the exception number if the CPU is handling an exception, or 0 otherwise"]
    pub fn __get_current_exception() -> uint;
}
pub const PICO_OK: crate::ctypes::c_int = 0;
pub const PICO_ERROR_NONE: crate::ctypes::c_int = 0;
pub const PICO_ERROR_TIMEOUT: crate::ctypes::c_int = -1;
pub const PICO_ERROR_GENERIC: crate::ctypes::c_int = -2;
pub const PICO_ERROR_NO_DATA: crate::ctypes::c_int = -3;
#[doc = " Common return codes from pico_sdk methods that return a status"]
pub type _bindgen_ty_1 = crate::ctypes::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stdio_driver {
    _unused: [u8; 0],
}
pub type stdio_driver_t = stdio_driver;
extern "C" {
    #[doc = " \\brief Initialize all of the present standard stdio types that are linked into the binary."]
    #[doc = " \\ingroup pico_stdio"]
    #[doc = ""]
    #[doc = " Call this method once you have set up your clocks to enable the stdio support for UART, USB"]
    #[doc = " and semihosting based on the presence of the respective libraries in the binary."]
    #[doc = ""]
    #[doc = " \\see stdio_uart, stdio_usb, stdio_semihosting"]
    pub fn stdio_init_all();
}
extern "C" {
    #[doc = " \\brief Initialize all of the present standard stdio types that are linked into the binary."]
    #[doc = " \\ingroup pico_stdio"]
    #[doc = ""]
    #[doc = " Call this method once you have set up your clocks to enable the stdio support for UART, USB"]
    #[doc = " and semihosting based on the presence of the respective libraries in the binary."]
    #[doc = ""]
    #[doc = " \\see stdio_uart, stdio_usb, stdio_semihosting"]
    pub fn stdio_flush();
}
extern "C" {
    #[doc = " \\brief Return a character from stdin if there is one available within a timeout"]
    #[doc = " \\ingroup pico_stdio"]
    #[doc = ""]
    #[doc = " \\param timeout_us the timeout in microseconds, or 0 to not wait for a character if none available."]
    #[doc = " \\return the character from 0-255 or PICO_ERROR_TIMEOUT if timeout occurs"]
    pub fn getchar_timeout_us(timeout_us: u32) -> crate::ctypes::c_int;
}
extern "C" {
    #[doc = " \\brief Adds or removes a driver from the list of active drivers used for input/output"]
    #[doc = " \\ingroup pico_stdio"]
    #[doc = ""]
    #[doc = " \\note this method should always be called on an initialized driver"]
    #[doc = " \\param driver the driver"]
    #[doc = " \\param enabled true to add, false to remove"]
    pub fn stdio_set_driver_enabled(driver: *mut stdio_driver_t, enabled: bool);
}
extern "C" {
    #[doc = " \\brief Control limiting of output to a single driver"]
    #[doc = " \\ingroup pico_stdio"]
    #[doc = ""]
    #[doc = " \\note this method should always be called on an initialized driver"]
    #[doc = ""]
    #[doc = " \\param driver if non-null then output only that driver will be used for input/output (assuming it is in the list of enabled drivers)."]
    #[doc = "               if NULL then all enabled drivers will be used"]
    pub fn stdio_filter_driver(driver: *mut stdio_driver_t);
}
extern "C" {
    #[doc = " \\brief control conversion of line feeds to carriage return on transmissions"]
    #[doc = " \\ingroup pico_stdio"]
    #[doc = ""]
    #[doc = " \\note this method should always be called on an initialized driver"]
    #[doc = ""]
    #[doc = " \\param driver the driver"]
    #[doc = " \\param translate If true, convert line feeds to carriage return on transmissions"]
    pub fn stdio_set_translate_crlf(driver: *mut stdio_driver_t, translate: bool);
}
pub type io_rw_32 = u32;
pub type io_ro_32 = u32;
pub type io_wo_32 = u32;
pub type io_rw_16 = u16;
pub type io_ro_16 = u16;
pub type io_wo_16 = u16;
pub type io_rw_8 = u8;
pub type io_ro_8 = u8;
pub type io_wo_8 = u8;
pub type ioptr = *mut u8;
pub type const_ioptr = ioptr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timer_hw_t {
    pub timehw: io_wo_32,
    pub timelw: io_wo_32,
    pub timehr: io_ro_32,
    pub timelr: io_ro_32,
    pub alarm: [io_rw_32; 4usize],
    pub armed: io_rw_32,
    pub timerawh: io_ro_32,
    pub timerawl: io_ro_32,
    pub dbgpause: io_rw_32,
    pub pause: io_rw_32,
    pub intr: io_rw_32,
    pub inte: io_rw_32,
    pub intf: io_rw_32,
    pub ints: io_ro_32,
}
extern "C" {
    #[doc = " \\brief Return the current 64 bit timestamp value in microseconds"]
    #[doc = "  \\ingroup hardware_timer"]
    #[doc = ""]
    #[doc = " Returns the full 64 bits of the hardware timer. The \\ref pico_time and other functions rely on the fact that this"]
    #[doc = " value monotonically increases from power up. As such it is expected that this value counts upwards and never wraps"]
    #[doc = " (we apologize for introducing a potential year 5851444 bug)."]
    #[doc = ""]
    #[doc = " \\return the 64 bit timestamp"]
    pub fn time_us_64() -> u64;
}
extern "C" {
    #[doc = " \\brief Busy wait wasting cycles for the given (32 bit) number of microseconds"]
    #[doc = "  \\ingroup hardware_timer"]
    #[doc = ""]
    #[doc = " \\param delay_us delay amount in microseconds"]
    pub fn busy_wait_us_32(delay_us: u32);
}
extern "C" {
    #[doc = " \\brief Busy wait wasting cycles for the given (64 bit) number of microseconds"]
    #[doc = "  \\ingroup hardware_timer"]
    #[doc = ""]
    #[doc = " \\param delay_us delay amount in microseconds"]
    pub fn busy_wait_us(delay_us: u64);
}
extern "C" {
    #[doc = " \\brief Busy wait wasting cycles for the given number of milliseconds"]
    #[doc = "  \\ingroup hardware_timer"]
    #[doc = ""]
    #[doc = " \\param delay_ms delay amount in milliseconds"]
    pub fn busy_wait_ms(delay_ms: u32);
}
extern "C" {
    #[doc = " \\brief Busy wait wasting cycles until after the specified timestamp"]
    #[doc = "  \\ingroup hardware_timer"]
    #[doc = ""]
    #[doc = " \\param t Absolute time to wait until"]
    pub fn busy_wait_until(t: absolute_time_t);
}
#[doc = " Callback function type for hardware alarms"]
#[doc = "  \\ingroup hardware_timer"]
#[doc = ""]
#[doc = " \\param alarm_num the hardware alarm number"]
#[doc = " \\sa hardware_alarm_set_callback()"]
pub type hardware_alarm_callback_t = ::core::option::Option<unsafe extern "C" fn(alarm_num: uint)>;
extern "C" {
    #[doc = " \\brief cooperatively claim the use of this hardware alarm_num"]
    #[doc = "  \\ingroup hardware_timer"]
    #[doc = ""]
    #[doc = " This method hard asserts if the hardware alarm is currently claimed."]
    #[doc = ""]
    #[doc = " \\param alarm_num the hardware alarm to claim"]
    #[doc = " \\sa hardware_claiming"]
    pub fn hardware_alarm_claim(alarm_num: uint);
}
extern "C" {
    #[doc = " \\brief cooperatively release the claim on use of this hardware alarm_num"]
    #[doc = "  \\ingroup hardware_timer"]
    #[doc = ""]
    #[doc = " \\param alarm_num the hardware alarm to unclaim"]
    #[doc = " \\sa hardware_claiming"]
    pub fn hardware_alarm_unclaim(alarm_num: uint);
}
extern "C" {
    #[doc = " \\brief Determine if a hardware alarm has been claimed"]
    #[doc = "  \\ingroup hardware_timer"]
    #[doc = ""]
    #[doc = " \\param alarm_num the hardware alarm number"]
    #[doc = " \\return true if claimed, false otherwise"]
    #[doc = " \\see hardware_alarm_claim"]
    pub fn hardware_alarm_is_claimed(alarm_num: uint) -> bool;
}
extern "C" {
    #[doc = " \\brief Enable/Disable a callback for a hardware timer on this core"]
    #[doc = "  \\ingroup hardware_timer"]
    #[doc = ""]
    #[doc = " This method enables/disables the alarm IRQ for the specified hardware alarm on the"]
    #[doc = " calling core, and set the specified callback to be associated with that alarm."]
    #[doc = ""]
    #[doc = " This callback will be used for the timeout set via hardware_alarm_set_target"]
    #[doc = ""]
    #[doc = " \\note This will install the handler on the current core if the IRQ handler isn't already set."]
    #[doc = " Therefore the user has the opportunity to call this up from the core of their choice"]
    #[doc = ""]
    #[doc = " \\param alarm_num the hardware alarm number"]
    #[doc = " \\param callback the callback to install, or NULL to unset"]
    #[doc = ""]
    #[doc = " \\sa hardware_alarm_set_target()"]
    pub fn hardware_alarm_set_callback(alarm_num: uint, callback: hardware_alarm_callback_t);
}
extern "C" {
    #[doc = " \\brief Set the current target for the specified hardware alarm"]
    #[doc = " \\ingroup hardware_timer"]
    #[doc = ""]
    #[doc = " This will replace any existing target"]
    #[doc = ""]
    #[doc = " @param alarm_num the hardware alarm number"]
    #[doc = " @param t the target timestamp"]
    #[doc = " @return true if the target was \"missed\"; i.e. it was in the past, or occurred before a future hardware timeout could be set"]
    pub fn hardware_alarm_set_target(alarm_num: uint, t: absolute_time_t) -> bool;
}
extern "C" {
    #[doc = " \\brief Cancel an existing target (if any) for a given hardware_alarm"]
    #[doc = " \\ingroup hardware_timer"]
    #[doc = ""]
    #[doc = " @param alarm_num"]
    pub fn hardware_alarm_cancel(alarm_num: uint);
}
extern "C" {
    pub static at_the_end_of_time: absolute_time_t;
}
extern "C" {
    pub static nil_time: absolute_time_t;
}
extern "C" {
    #[doc = " \\brief Wait until after the given timestamp to return"]
    #[doc = " \\ingroup sleep"]
    #[doc = ""]
    #[doc = " \\note  This method attempts to perform a lower power (WFE) sleep"]
    #[doc = ""]
    #[doc = " \\param target the time after which to return"]
    #[doc = " \\sa sleep_us()"]
    #[doc = " \\sa busy_wait_until()"]
    pub fn sleep_until(target: absolute_time_t);
}
extern "C" {
    #[doc = " \\brief Wait for the given number of microseconds before returning"]
    #[doc = " \\ingroup sleep"]
    #[doc = ""]
    #[doc = " \\note This method attempts to perform a lower power (WFE) sleep"]
    #[doc = ""]
    #[doc = " \\param us the number of microseconds to sleep"]
    #[doc = " \\sa busy_wait_us()"]
    pub fn sleep_us(us: u64);
}
extern "C" {
    #[doc = " \\brief Wait for the given number of milliseconds before returning"]
    #[doc = " \\ingroup sleep"]
    #[doc = ""]
    #[doc = " \\note This method attempts to perform a lower power sleep (using WFE) as much as possible."]
    #[doc = ""]
    #[doc = " \\param ms the number of milliseconds to sleep"]
    pub fn sleep_ms(ms: u32);
}
extern "C" {
    #[doc = " \\brief Helper method for blocking on a timeout"]
    #[doc = " \\ingroup sleep"]
    #[doc = ""]
    #[doc = " This method will return in response to an event (as per __wfe) or"]
    #[doc = " when the target time is reached, or at any point before."]
    #[doc = ""]
    #[doc = " This method can be used to implement a lower power polling loop waiting on"]
    #[doc = " some condition signalled by an event (__sev())."]
    #[doc = ""]
    #[doc = " This is called \\a best_effort because under certain circumstances (notably the default timer pool"]
    #[doc = " being disabled or full) the best effort is simply to return immediately without a __wfe, thus turning the calling"]
    #[doc = " code into a busy wait."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " ```c"]
    #[doc = " bool my_function_with_timeout_us(uint64_t timeout_us) {"]
    #[doc = "     absolute_time_t timeout_time = make_timeout_time_us(timeout_us);"]
    #[doc = "     do {"]
    #[doc = "         // each time round the loop, we check to see if the condition"]
    #[doc = "         // we are waiting on has happened"]
    #[doc = "         if (my_check_done()) {"]
    #[doc = "             // do something"]
    #[doc = "             return true;"]
    #[doc = "         }"]
    #[doc = "         // will try to sleep until timeout or the next processor event"]
    #[doc = "     } while (!best_effort_wfe_or_timeout(timeout_time));"]
    #[doc = "     return false; // timed out"]
    #[doc = " }"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " @param timeout_timestamp the timeout time"]
    #[doc = " @return true if the target time is reached, false otherwise"]
    pub fn best_effort_wfe_or_timeout(timeout_timestamp: absolute_time_t) -> bool;
}
#[doc = " \\brief The identifier for an alarm"]
#[doc = ""]
#[doc = " \\note this identifier is signed because -1 is used as an error condition when creating alarms"]
#[doc = ""]
#[doc = " \\note alarm ids may be reused, however for convenience the implementation makes an attempt to defer"]
#[doc = " reusing as long as possible. You should certainly expect it to be hundreds of ids before one is"]
#[doc = " reused, although in most cases it is more. Nonetheless care must still be taken when cancelling"]
#[doc = " alarms or other functionality based on alarms when the alarm may have expired, as eventually"]
#[doc = " the alarm id may be reused for another alarm."]
#[doc = ""]
#[doc = " \\ingroup alarm"]
pub type alarm_id_t = i32;
#[doc = " \\brief User alarm callback"]
#[doc = " \\ingroup alarm"]
#[doc = " \\param id the alarm_id as returned when the alarm was added"]
#[doc = " \\param user_data the user data passed when the alarm was added"]
#[doc = " \\return <0 to reschedule the same alarm this many us from the time the alarm was previously scheduled to fire"]
#[doc = " \\return >0 to reschedule the same alarm this many us from the time this method returns"]
#[doc = " \\return 0 to not reschedule the alarm"]
pub type alarm_callback_t = ::core::option::Option<
    unsafe extern "C" fn(id: alarm_id_t, user_data: *mut crate::ctypes::c_void) -> i64,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alarm_pool {
    _unused: [u8; 0],
}
pub type alarm_pool_t = alarm_pool;
extern "C" {
    #[doc = " \\brief Create the default alarm pool (if not already created or disabled)"]
    #[doc = " \\ingroup alarm"]
    pub fn alarm_pool_init_default();
}
extern "C" {
    #[doc = " \\brief The default alarm pool used when alarms are added without specifying an alarm pool,"]
    #[doc = "        and also used by the SDK to support lower power sleeps and timeouts."]
    #[doc = ""]
    #[doc = " \\ingroup alarm"]
    #[doc = " \\sa #PICO_TIME_DEFAULT_ALARM_POOL_HARDWARE_ALARM_NUM"]
    pub fn alarm_pool_get_default() -> *mut alarm_pool_t;
}
extern "C" {
    #[doc = " \\brief Create an alarm pool"]
    #[doc = ""]
    #[doc = " The alarm pool will call callbacks from an alarm IRQ Handler on the core of this function is called from."]
    #[doc = ""]
    #[doc = " In many situations there is never any need for anything other than the default alarm pool, however you"]
    #[doc = " might want to create another if you want alarm callbacks on core 1 or require alarm pools of"]
    #[doc = " different priority (IRQ priority based preemption of callbacks)"]
    #[doc = ""]
    #[doc = " \\note This method will hard assert if the hardware alarm is already claimed."]
    #[doc = ""]
    #[doc = " \\ingroup alarm"]
    #[doc = " \\param hardware_alarm_num the hardware alarm to use to back this pool"]
    #[doc = " \\param max_timers the maximum number of timers"]
    #[doc = "        \\note For implementation reasons this is limited to PICO_PHEAP_MAX_ENTRIES which defaults to 255"]
    #[doc = " \\sa alarm_pool_get_default()"]
    #[doc = " \\sa hardware_claiming"]
    pub fn alarm_pool_create(hardware_alarm_num: uint, max_timers: uint) -> *mut alarm_pool_t;
}
extern "C" {
    #[doc = " \\brief Return the hardware alarm used by an alarm pool"]
    #[doc = " \\ingroup alarm"]
    #[doc = " \\param pool the pool"]
    #[doc = " \\return the hardware alarm used by the pool"]
    pub fn alarm_pool_hardware_alarm_num(pool: *mut alarm_pool_t) -> uint;
}
extern "C" {
    #[doc = " \\brief Destroy the alarm pool, cancelling all alarms and freeing up the underlying hardware alarm"]
    #[doc = " \\ingroup alarm"]
    #[doc = " \\param pool the pool"]
    #[doc = " \\return the hardware alarm used by the pool"]
    pub fn alarm_pool_destroy(pool: *mut alarm_pool_t);
}
extern "C" {
    #[doc = " \\brief Add an alarm callback to be called at a specific time"]
    #[doc = " \\ingroup alarm"]
    #[doc = ""]
    #[doc = " Generally the callback is called as soon as possible after the time specified from an IRQ handler"]
    #[doc = " on the core the alarm pool was created on. If the callback is in the past or happens before"]
    #[doc = " the alarm setup could be completed, then this method will optionally call the callback itself"]
    #[doc = " and then return a return code to indicate that the target time has passed."]
    #[doc = ""]
    #[doc = " \\note It is safe to call this method from an IRQ handler (including alarm callbacks), and from either core."]
    #[doc = ""]
    #[doc = " @param pool the alarm pool to use for scheduling the callback (this determines which hardware alarm is used, and which core calls the callback)"]
    #[doc = " @param time the timestamp when (after which) the callback should fire"]
    #[doc = " @param callback the callback function"]
    #[doc = " @param user_data user data to pass to the callback function"]
    #[doc = " @param fire_if_past if true, this method will call the callback itself before returning 0 if the timestamp happens before or during this method call"]
    #[doc = " @return >0 the alarm id"]
    #[doc = " @return 0 the target timestamp was during or before this method call (whether the callback was called depends on fire_if_past)"]
    #[doc = " @return -1 if there were no alarm slots available"]
    pub fn alarm_pool_add_alarm_at(
        pool: *mut alarm_pool_t,
        time: absolute_time_t,
        callback: alarm_callback_t,
        user_data: *mut crate::ctypes::c_void,
        fire_if_past: bool,
    ) -> alarm_id_t;
}
extern "C" {
    #[doc = " \\brief Cancel an alarm"]
    #[doc = " \\ingroup alarm"]
    #[doc = " \\param pool the alarm_pool containing the alarm"]
    #[doc = " \\param alarm_id the alarm"]
    #[doc = " \\return true if the alarm was cancelled, false if it didn't exist"]
    #[doc = " \\sa alarm_id_t for a note on reuse of IDs"]
    pub fn alarm_pool_cancel_alarm(pool: *mut alarm_pool_t, alarm_id: alarm_id_t) -> bool;
}
#[doc = " \\defgroup repeating_timer repeating_timer"]
#[doc = " \\ingroup pico_time"]
#[doc = " \\brief Repeating Timer functions for simple scheduling of repeated execution"]
#[doc = ""]
#[doc = " \\note The regular \\a alarm_ functionality can be used to make repeating alarms (by return non zero from the callback),"]
#[doc = " however these methods abstract that further (at the cost of a user structure to store the repeat delay in (which"]
#[doc = " the alarm framework does not have space for)."]
pub type repeating_timer_t = repeating_timer;
#[doc = " \\brief Callback for a repeating timer"]
#[doc = " \\ingroup repeating_timer"]
#[doc = " \\param rt repeating time structure containing information about the repeating time. user_data is of primary important to the user"]
#[doc = " \\return true to continue repeating, false to stop."]
pub type repeating_timer_callback_t =
    ::core::option::Option<unsafe extern "C" fn(rt: *mut repeating_timer_t) -> bool>;
#[doc = " \\brief Information about a repeating timer"]
#[doc = " \\ingroup repeating_timer"]
#[doc = " \\return"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct repeating_timer {
    pub delay_us: i64,
    pub pool: *mut alarm_pool_t,
    pub alarm_id: alarm_id_t,
    pub callback: repeating_timer_callback_t,
    pub user_data: *mut crate::ctypes::c_void,
}
extern "C" {
    #[doc = " \\brief Add a repeating timer that is called repeatedly at the specified interval in microseconds"]
    #[doc = " \\ingroup repeating_timer"]
    #[doc = ""]
    #[doc = " Generally the callback is called as soon as possible after the time specified from an IRQ handler"]
    #[doc = " on the core the alarm pool was created on. If the callback is in the past or happens before"]
    #[doc = " the alarm setup could be completed, then this method will optionally call the callback itself"]
    #[doc = " and then return a return code to indicate that the target time has passed."]
    #[doc = ""]
    #[doc = " \\note It is safe to call this method from an IRQ handler (including alarm callbacks), and from either core."]
    #[doc = ""]
    #[doc = " @param pool the alarm pool to use for scheduling the repeating timer (this determines which hardware alarm is used, and which core calls the callback)"]
    #[doc = " @param delay_us the repeat delay in microseconds; if >0 then this is the delay between one callback ending and the next starting; if <0 then this is the negative of the time between the starts of the callbacks. The value of 0 is treated as 1"]
    #[doc = " @param callback the repeating timer callback function"]
    #[doc = " @param user_data user data to pass to store in the repeating_timer structure for use by the callback."]
    #[doc = " @param out the pointer to the user owned structure to store the repeating timer info in. BEWARE this storage location must outlive the repeating timer, so be careful of using stack space"]
    #[doc = " @return false if there were no alarm slots available to create the timer, true otherwise."]
    pub fn alarm_pool_add_repeating_timer_us(
        pool: *mut alarm_pool_t,
        delay_us: i64,
        callback: repeating_timer_callback_t,
        user_data: *mut crate::ctypes::c_void,
        out: *mut repeating_timer_t,
    ) -> bool;
}
extern "C" {
    #[doc = " \\brief Cancel a repeating timer"]
    #[doc = " \\ingroup repeating_timer"]
    #[doc = " \\param timer the repeating timer to cancel"]
    #[doc = " \\return true if the repeating timer was cancelled, false if it didn't exist"]
    #[doc = " \\sa alarm_id_t for a note on reuse of IDs"]
    pub fn cancel_repeating_timer(timer: *mut repeating_timer_t) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct interp_hw_t {
    pub accum: [io_rw_32; 2usize],
    pub base: [io_rw_32; 3usize],
    pub pop: [io_ro_32; 3usize],
    pub peek: [io_ro_32; 3usize],
    pub ctrl: [io_rw_32; 2usize],
    pub add_raw: [io_rw_32; 2usize],
    pub base01: io_wo_32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sio_hw_t {
    pub cpuid: io_ro_32,
    pub gpio_in: io_ro_32,
    pub gpio_hi_in: io_ro_32,
    pub _pad: u32,
    pub gpio_out: io_rw_32,
    pub gpio_set: io_wo_32,
    pub gpio_clr: io_wo_32,
    pub gpio_togl: io_wo_32,
    pub gpio_oe: io_wo_32,
    pub gpio_oe_set: io_wo_32,
    pub gpio_oe_clr: io_wo_32,
    pub gpio_oe_togl: io_wo_32,
    pub gpio_hi_out: io_rw_32,
    pub gpio_hi_set: io_wo_32,
    pub gpio_hi_clr: io_wo_32,
    pub gpio_hi_togl: io_wo_32,
    pub gpio_hi_oe: io_wo_32,
    pub gpio_hi_oe_set: io_wo_32,
    pub gpio_hi_oe_clr: io_wo_32,
    pub gpio_hi_oe_togl: io_wo_32,
    pub fifo_st: io_rw_32,
    pub fifo_wr: io_wo_32,
    pub fifo_rd: io_ro_32,
    pub spinlock_st: io_ro_32,
    pub div_udividend: io_rw_32,
    pub div_udivisor: io_rw_32,
    pub div_sdividend: io_rw_32,
    pub div_sdivisor: io_rw_32,
    pub div_quotient: io_rw_32,
    pub div_remainder: io_rw_32,
    pub div_csr: io_rw_32,
    pub _pad2: u32,
    pub interp: [interp_hw_t; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct padsbank0_hw_t {
    pub voltage_select: io_rw_32,
    pub io: [io_rw_32; 30usize],
}
pub const GPIO_FUNC_XIP: gpio_function = 0;
pub const GPIO_FUNC_SPI: gpio_function = 1;
pub const GPIO_FUNC_UART: gpio_function = 2;
pub const GPIO_FUNC_I2C: gpio_function = 3;
pub const GPIO_FUNC_PWM: gpio_function = 4;
pub const GPIO_FUNC_SIO: gpio_function = 5;
pub const GPIO_FUNC_PIO0: gpio_function = 6;
pub const GPIO_FUNC_PIO1: gpio_function = 7;
pub const GPIO_FUNC_GPCK: gpio_function = 8;
pub const GPIO_FUNC_USB: gpio_function = 9;
pub const GPIO_FUNC_NULL: gpio_function = 31;
#[doc = " \\brief  GPIO function definitions for use with function select"]
#[doc = "  \\ingroup hardware_gpio"]
#[doc = " \\brief GPIO function selectors"]
#[doc = ""]
#[doc = " Each GPIO can have one function selected at a time. Likewise, each peripheral input (e.g. UART0 RX) should only be"]
#[doc = " selected on one GPIO at a time. If the same peripheral input is connected to multiple GPIOs, the peripheral sees the logical"]
#[doc = " OR of these GPIO inputs."]
#[doc = ""]
#[doc = " Please refer to the datsheet for more information on GPIO function selection."]
pub type gpio_function = crate::ctypes::c_uint;
pub const GPIO_IRQ_LEVEL_LOW: gpio_irq_level = 1;
pub const GPIO_IRQ_LEVEL_HIGH: gpio_irq_level = 2;
pub const GPIO_IRQ_EDGE_FALL: gpio_irq_level = 4;
pub const GPIO_IRQ_EDGE_RISE: gpio_irq_level = 8;
#[doc = " \\brief  GPIO Interrupt level definitions"]
#[doc = "  \\ingroup hardware_gpio"]
#[doc = "  \\brief GPIO Interrupt levels"]
#[doc = ""]
#[doc = " An interrupt can be generated for every GPIO pin in 4 scenarios:"]
#[doc = ""]
#[doc = " * Level High: the GPIO pin is a logical 1"]
#[doc = " * Level Low: the GPIO pin is a logical 0"]
#[doc = " * Edge High: the GPIO has transitioned from a logical 0 to a logical 1"]
#[doc = " * Edge Low: the GPIO has transitioned from a logical 1 to a logical 0"]
#[doc = ""]
#[doc = " The level interrupts are not latched. This means that if the pin is a logical 1 and the level high interrupt is active, it will"]
#[doc = " become inactive as soon as the pin changes to a logical 0. The edge interrupts are stored in the INTR register and can be"]
#[doc = " cleared by writing to the INTR register."]
pub type gpio_irq_level = crate::ctypes::c_uint;
#[doc = " Callback function type for GPIO events"]
#[doc = "  \\ingroup hardware_gpio"]
#[doc = ""]
#[doc = " \\param gpio Which GPIO caused this interrupt"]
#[doc = " \\param events Which events caused this interrupt. See \\ref gpio_set_irq_enabled for details."]
#[doc = " \\sa gpio_set_irq_enabled_with_callback()"]
pub type gpio_irq_callback_t =
    ::core::option::Option<unsafe extern "C" fn(gpio: uint, events: u32)>;
#[doc = "< peripheral signal selected via \\ref gpio_set_function"]
pub const GPIO_OVERRIDE_NORMAL: gpio_override = 0;
#[doc = "< invert peripheral signal selected via \\ref gpio_set_function"]
pub const GPIO_OVERRIDE_INVERT: gpio_override = 1;
#[doc = "< drive low/disable output"]
pub const GPIO_OVERRIDE_LOW: gpio_override = 2;
#[doc = "< drive high/enable output"]
pub const GPIO_OVERRIDE_HIGH: gpio_override = 3;
pub type gpio_override = crate::ctypes::c_uint;
#[doc = "< Slew rate limiting enabled"]
pub const GPIO_SLEW_RATE_SLOW: gpio_slew_rate = 0;
#[doc = "< Slew rate limiting disabled"]
pub const GPIO_SLEW_RATE_FAST: gpio_slew_rate = 1;
#[doc = " \\brief Slew rate limiting levels for GPIO outputs"]
#[doc = "  \\ingroup hardware_gpio"]
#[doc = ""]
#[doc = " Slew rate limiting increases the minimum rise/fall time when a GPIO output"]
#[doc = " is lightly loaded, which can help to reduce electromagnetic emissions."]
#[doc = " \\sa gpio_set_slew_rate"]
pub type gpio_slew_rate = crate::ctypes::c_uint;
#[doc = "< 2 mA nominal drive strength"]
pub const GPIO_DRIVE_STRENGTH_2MA: gpio_drive_strength = 0;
#[doc = "< 4 mA nominal drive strength"]
pub const GPIO_DRIVE_STRENGTH_4MA: gpio_drive_strength = 1;
#[doc = "< 8 mA nominal drive strength"]
pub const GPIO_DRIVE_STRENGTH_8MA: gpio_drive_strength = 2;
#[doc = "< 12 mA nominal drive strength"]
pub const GPIO_DRIVE_STRENGTH_12MA: gpio_drive_strength = 3;
#[doc = " \\brief Drive strength levels for GPIO outputs"]
#[doc = "  \\ingroup hardware_gpio"]
#[doc = ""]
#[doc = " Drive strength levels for GPIO outputs."]
#[doc = " \\sa gpio_set_drive_strength"]
pub type gpio_drive_strength = crate::ctypes::c_uint;
extern "C" {
    #[doc = " \\brief Select GPIO function"]
    #[doc = "  \\ingroup hardware_gpio"]
    #[doc = ""]
    #[doc = " \\param gpio GPIO number"]
    #[doc = " \\param fn Which GPIO function select to use from list \\ref gpio_function"]
    pub fn gpio_set_function(gpio: uint, fn_: gpio_function);
}
extern "C" {
    pub fn gpio_get_function(gpio: uint) -> gpio_function;
}
extern "C" {
    #[doc = " \\brief Select up and down pulls on specific GPIO"]
    #[doc = "  \\ingroup hardware_gpio"]
    #[doc = ""]
    #[doc = " \\param gpio GPIO number"]
    #[doc = " \\param up If true set a pull up on the GPIO"]
    #[doc = " \\param down If true set a pull down on the GPIO"]
    #[doc = ""]
    #[doc = " \\note On the RP2040, setting both pulls enables a \"bus keep\" function,"]
    #[doc = " i.e. a weak pull to whatever is current high/low state of GPIO."]
    pub fn gpio_set_pulls(gpio: uint, up: bool, down: bool);
}
extern "C" {
    #[doc = " \\brief Set GPIO IRQ override"]
    #[doc = "  \\ingroup hardware_gpio"]
    #[doc = ""]
    #[doc = " Optionally invert a GPIO IRQ signal, or drive it high or low"]
    #[doc = ""]
    #[doc = " \\param gpio GPIO number"]
    #[doc = " \\param value See \\ref gpio_override"]
    pub fn gpio_set_irqover(gpio: uint, value: uint);
}
extern "C" {
    #[doc = " \\brief Set GPIO output override"]
    #[doc = "  \\ingroup hardware_gpio"]
    #[doc = ""]
    #[doc = " \\param gpio GPIO number"]
    #[doc = " \\param value See \\ref gpio_override"]
    pub fn gpio_set_outover(gpio: uint, value: uint);
}
extern "C" {
    #[doc = " \\brief Select GPIO input override"]
    #[doc = "  \\ingroup hardware_gpio"]
    #[doc = ""]
    #[doc = " \\param gpio GPIO number"]
    #[doc = " \\param value See \\ref gpio_override"]
    pub fn gpio_set_inover(gpio: uint, value: uint);
}
extern "C" {
    #[doc = " \\brief Select GPIO output enable override"]
    #[doc = "  \\ingroup hardware_gpio"]
    #[doc = ""]
    #[doc = " \\param gpio GPIO number"]
    #[doc = " \\param value See \\ref gpio_override"]
    pub fn gpio_set_oeover(gpio: uint, value: uint);
}
extern "C" {
    #[doc = " \\brief Enable GPIO input"]
    #[doc = "  \\ingroup hardware_gpio"]
    #[doc = ""]
    #[doc = " \\param gpio GPIO number"]
    #[doc = " \\param enabled true to enable input on specified GPIO"]
    pub fn gpio_set_input_enabled(gpio: uint, enabled: bool);
}
extern "C" {
    #[doc = " \\brief Enable/disable GPIO input hysteresis (Schmitt trigger)"]
    #[doc = "  \\ingroup hardware_gpio"]
    #[doc = ""]
    #[doc = " Enable or disable the Schmitt trigger hysteresis on a given GPIO. This is"]
    #[doc = " enabled on all GPIOs by default. Disabling input hysteresis can lead to"]
    #[doc = " inconsistent readings when the input signal has very long rise or fall"]
    #[doc = " times, but slightly reduces the GPIO's input delay."]
    #[doc = ""]
    #[doc = " \\sa gpio_is_input_hysteresis_enabled"]
    #[doc = " \\param gpio GPIO number"]
    #[doc = " \\param enabled true to enable input hysteresis on specified GPIO"]
    pub fn gpio_set_input_hysteresis_enabled(gpio: uint, enabled: bool);
}
extern "C" {
    #[doc = " \\brief Determine whether input hysteresis is enabled on a specified GPIO"]
    #[doc = "  \\ingroup hardware_gpio"]
    #[doc = ""]
    #[doc = " \\sa gpio_set_input_hysteresis_enabled"]
    #[doc = " \\param gpio GPIO number"]
    pub fn gpio_is_input_hysteresis_enabled(gpio: uint) -> bool;
}
extern "C" {
    #[doc = " \\brief Set slew rate for a specified GPIO"]
    #[doc = "  \\ingroup hardware_gpio"]
    #[doc = ""]
    #[doc = " \\sa gpio_get_slew_rate"]
    #[doc = " \\param gpio GPIO number"]
    #[doc = " \\param slew GPIO output slew rate"]
    pub fn gpio_set_slew_rate(gpio: uint, slew: gpio_slew_rate);
}
extern "C" {
    #[doc = " \\brief Determine current slew rate for a specified GPIO"]
    #[doc = "  \\ingroup hardware_gpio"]
    #[doc = ""]
    #[doc = " \\sa gpio_set_slew_rate"]
    #[doc = " \\param gpio GPIO number"]
    #[doc = " \\return Current slew rate of that GPIO"]
    pub fn gpio_get_slew_rate(gpio: uint) -> gpio_slew_rate;
}
extern "C" {
    #[doc = " \\brief Set drive strength for a specified GPIO"]
    #[doc = "  \\ingroup hardware_gpio"]
    #[doc = ""]
    #[doc = " \\sa gpio_get_drive_strength"]
    #[doc = " \\param gpio GPIO number"]
    #[doc = " \\param drive GPIO output drive strength"]
    pub fn gpio_set_drive_strength(gpio: uint, drive: gpio_drive_strength);
}
extern "C" {
    #[doc = " \\brief Determine current slew rate for a specified GPIO"]
    #[doc = "  \\ingroup hardware_gpio"]
    #[doc = ""]
    #[doc = " \\sa gpio_set_drive_strength"]
    #[doc = " \\param gpio GPIO number"]
    #[doc = " \\return Current drive strength of that GPIO"]
    pub fn gpio_get_drive_strength(gpio: uint) -> gpio_drive_strength;
}
extern "C" {
    #[doc = " \\brief Enable or disable interrupts for specified GPIO"]
    #[doc = "  \\ingroup hardware_gpio"]
    #[doc = ""]
    #[doc = " \\note The IO IRQs are independent per-processor. This configures IRQs for"]
    #[doc = " the processor that calls the function."]
    #[doc = ""]
    #[doc = " \\param gpio GPIO number"]
    #[doc = " \\param events Which events will cause an interrupt"]
    #[doc = " \\param enabled Enable or disable flag"]
    #[doc = ""]
    #[doc = " Events is a bitmask of the following:"]
    #[doc = ""]
    #[doc = " bit | interrupt"]
    #[doc = " ----|----------"]
    #[doc = "   0 | Low level"]
    #[doc = "   1 | High level"]
    #[doc = "   2 | Edge low"]
    #[doc = "   3 | Edge high"]
    pub fn gpio_set_irq_enabled(gpio: uint, events: u32, enabled: bool);
}
extern "C" {
    #[doc = " \\brief Enable interrupts for specified GPIO"]
    #[doc = "  \\ingroup hardware_gpio"]
    #[doc = ""]
    #[doc = " \\note The IO IRQs are independent per-processor. This configures IRQs for"]
    #[doc = " the processor that calls the function."]
    #[doc = ""]
    #[doc = " \\param gpio GPIO number"]
    #[doc = " \\param events Which events will cause an interrupt. See \\ref gpio_set_irq_enabled for details."]
    #[doc = " \\param enabled Enable or disable flag"]
    #[doc = " \\param callback user function to call on GPIO irq. Note only one of these can be set per processor."]
    #[doc = ""]
    #[doc = " \\note Currently the GPIO parameter is ignored, and this callback will be called for any enabled GPIO IRQ on any pin."]
    #[doc = ""]
    pub fn gpio_set_irq_enabled_with_callback(
        gpio: uint,
        events: u32,
        enabled: bool,
        callback: gpio_irq_callback_t,
    );
}
extern "C" {
    #[doc = " \\brief Enable dormant wake up interrupt for specified GPIO"]
    #[doc = "  \\ingroup hardware_gpio"]
    #[doc = ""]
    #[doc = " This configures IRQs to restart the XOSC or ROSC when they are"]
    #[doc = " disabled in dormant mode"]
    #[doc = ""]
    #[doc = " \\param gpio GPIO number"]
    #[doc = " \\param events Which events will cause an interrupt. See \\ref gpio_set_irq_enabled for details."]
    #[doc = " \\param enabled Enable/disable flag"]
    pub fn gpio_set_dormant_irq_enabled(gpio: uint, events: u32, enabled: bool);
}
extern "C" {
    #[doc = " \\brief Acknowledge a GPIO interrupt"]
    #[doc = "  \\ingroup hardware_gpio"]
    #[doc = ""]
    #[doc = " \\param gpio GPIO number"]
    #[doc = " \\param events Bitmask of events to clear. See \\ref gpio_set_irq_enabled for details."]
    #[doc = ""]
    pub fn gpio_acknowledge_irq(gpio: uint, events: u32);
}
extern "C" {
    #[doc = " \\brief Initialise a GPIO for (enabled I/O and set func to GPIO_FUNC_SIO)"]
    #[doc = "  \\ingroup hardware_gpio"]
    #[doc = ""]
    #[doc = " Clear the output enable (i.e. set to input)"]
    #[doc = " Clear any output value."]
    #[doc = ""]
    #[doc = " \\param gpio GPIO number"]
    pub fn gpio_init(gpio: uint);
}
extern "C" {
    #[doc = " \\brief Initialise multiple GPIOs (enabled I/O and set func to GPIO_FUNC_SIO)"]
    #[doc = "  \\ingroup hardware_gpio"]
    #[doc = ""]
    #[doc = " Clear the output enable (i.e. set to input)"]
    #[doc = " Clear any output value."]
    #[doc = ""]
    #[doc = " \\param gpio_mask Mask with 1 bit per GPIO number to initialize"]
    pub fn gpio_init_mask(gpio_mask: uint);
}
extern "C" {
    pub fn gpio_debug_pins_init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_hw_t {
    pub dr: io_rw_32,
    pub rsr: io_rw_32,
    pub _pad0: [u32; 4usize],
    pub fr: io_rw_32,
    pub _pad1: u32,
    pub ilpr: io_rw_32,
    pub ibrd: io_rw_32,
    pub fbrd: io_rw_32,
    pub lcr_h: io_rw_32,
    pub cr: io_rw_32,
    pub ifls: io_rw_32,
    pub imsc: io_rw_32,
    pub ris: io_rw_32,
    pub mis: io_rw_32,
    pub icr: io_rw_32,
    pub dmacr: io_rw_32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_inst {
    _unused: [u8; 0],
}
#[doc = " \\file hardware/uart.h"]
#[doc = "  \\defgroup hardware_uart hardware_uart"]
#[doc = ""]
#[doc = " Hardware UART API"]
#[doc = ""]
#[doc = " RP2040 has 2 identical instances of a UART peripheral, based on the ARM PL011. Each UART can be connected to a number"]
#[doc = " of GPIO pins as defined in the GPIO muxing."]
#[doc = ""]
#[doc = " Only the TX, RX, RTS, and CTS signals are"]
#[doc = " connected, meaning that the modem mode and IrDA mode of the PL011 are not supported."]
#[doc = ""]
#[doc = " \\subsection uart_example Example"]
#[doc = " \\addtogroup hardware_uart"]
#[doc = ""]
#[doc = "  \\code"]
#[doc = "  int main() {"]
#[doc = ""]
#[doc = "     // Initialise UART 0"]
#[doc = "     uart_init(uart0, 115200);"]
#[doc = ""]
#[doc = "     // Set the GPIO pin mux to the UART - 0 is TX, 1 is RX"]
#[doc = "     gpio_set_function(0, GPIO_FUNC_UART);"]
#[doc = "     gpio_set_function(1, GPIO_FUNC_UART);"]
#[doc = ""]
#[doc = "     uart_puts(uart0, \"Hello world!\");"]
#[doc = " }"]
#[doc = " \\endcode"]
pub type uart_inst_t = uart_inst;
pub const UART_PARITY_NONE: uart_parity_t = 0;
pub const UART_PARITY_EVEN: uart_parity_t = 1;
pub const UART_PARITY_ODD: uart_parity_t = 2;
#[doc = " \\brief UART Parity enumeration"]
#[doc = "  \\ingroup hardware_uart"]
pub type uart_parity_t = crate::ctypes::c_uint;
extern "C" {
    #[doc = " \\brief Initialise a UART"]
    #[doc = "  \\ingroup hardware_uart"]
    #[doc = ""]
    #[doc = " Put the UART into a known state, and enable it. Must be called before other"]
    #[doc = " functions."]
    #[doc = ""]
    #[doc = " \\note There is no guarantee that the baudrate requested will be possible, the nearest will be chosen,"]
    #[doc = " and this function will return the configured baud rate."]
    #[doc = ""]
    #[doc = " \\param uart UART instance. \\ref uart0 or \\ref uart1"]
    #[doc = " \\param baudrate Baudrate of UART in Hz"]
    #[doc = " \\return Actual set baudrate"]
    pub fn uart_init(uart: *mut uart_inst_t, baudrate: uint) -> uint;
}
extern "C" {
    #[doc = " \\brief DeInitialise a UART"]
    #[doc = "  \\ingroup hardware_uart"]
    #[doc = ""]
    #[doc = " Disable the UART if it is no longer used. Must be reinitialised before"]
    #[doc = " being used again."]
    #[doc = ""]
    #[doc = " \\param uart UART instance. \\ref uart0 or \\ref uart1"]
    pub fn uart_deinit(uart: *mut uart_inst_t);
}
extern "C" {
    #[doc = " \\brief Set UART baud rate"]
    #[doc = "  \\ingroup hardware_uart"]
    #[doc = ""]
    #[doc = " Set baud rate as close as possible to requested, and return actual rate selected."]
    #[doc = ""]
    #[doc = " \\param uart UART instance. \\ref uart0 or \\ref uart1"]
    #[doc = " \\param baudrate Baudrate in Hz"]
    #[doc = " \\return Actual set baudrate"]
    pub fn uart_set_baudrate(uart: *mut uart_inst_t, baudrate: uint) -> uint;
}
extern "C" {
    #[doc = " \\brief Set CR/LF conversion on UART"]
    #[doc = "  \\ingroup hardware_uart"]
    #[doc = ""]
    #[doc = " \\param uart UART instance. \\ref uart0 or \\ref uart1"]
    #[doc = " \\param translate If true, convert line feeds to carriage return on transmissions"]
    pub fn uart_set_translate_crlf(uart: *mut uart_inst_t, translate: bool);
}
extern "C" {
    #[doc = " \\brief Wait for up to a certain number of microseconds for the RX FIFO to be non empty"]
    #[doc = "  \\ingroup hardware_uart"]
    #[doc = ""]
    #[doc = " \\param uart UART instance. \\ref uart0 or \\ref uart1"]
    #[doc = " \\param us the number of microseconds to wait at most (may be 0 for an instantaneous check)"]
    #[doc = " \\return true if the RX FIFO became non empty before the timeout, false otherwise"]
    pub fn uart_is_readable_within_us(uart: *mut uart_inst_t, us: u32) -> bool;
}
extern "C" {
    #[doc = " \\brief Set up the default UART and assign it to the default GPIO's"]
    #[doc = "  \\ingroup pico_stdlib"]
    #[doc = ""]
    #[doc = " By default this will use UART 0, with TX to pin GPIO 0,"]
    #[doc = " RX to pin GPIO 1, and the baudrate to 115200"]
    #[doc = ""]
    #[doc = " Calling this method also initializes stdin/stdout over UART if the"]
    #[doc = " @ref pico_stdio_uart library is linked."]
    #[doc = ""]
    #[doc = " Defaults can be changed using configuration defines,"]
    #[doc = "  PICO_DEFAULT_UART_INSTANCE,"]
    #[doc = "  PICO_DEFAULT_UART_BAUD_RATE"]
    #[doc = "  PICO_DEFAULT_UART_TX_PIN"]
    #[doc = "  PICO_DEFAULT_UART_RX_PIN"]
    pub fn setup_default_uart();
}
extern "C" {
    #[doc = " \\brief Initialise the system clock to 48MHz"]
    #[doc = "  \\ingroup pico_stdlib"]
    #[doc = ""]
    #[doc = "  Set the system clock to 48MHz, and set the peripheral clock to match."]
    pub fn set_sys_clock_48mhz();
}
extern "C" {
    #[doc = " \\brief Initialise the system clock"]
    #[doc = "  \\ingroup pico_stdlib"]
    #[doc = ""]
    #[doc = " \\param vco_freq The voltage controller oscillator frequency to be used by the SYS PLL"]
    #[doc = " \\param post_div1 The first post divider for the SYS PLL"]
    #[doc = " \\param post_div2 The second post divider for the SYS PLL."]
    #[doc = ""]
    #[doc = " See the PLL documentation in the datasheet for details of driving the PLLs."]
    pub fn set_sys_clock_pll(vco_freq: u32, post_div1: uint, post_div2: uint);
}
extern "C" {
    #[doc = " \\brief Check if a given system clock frequency is valid/attainable"]
    #[doc = "  \\ingroup pico_stdlib"]
    #[doc = ""]
    #[doc = " \\param freq_khz Requested frequency"]
    #[doc = " \\param vco_freq_out On success, the voltage controller oscillator frequeucny to be used by the SYS PLL"]
    #[doc = " \\param post_div1_out On success, The first post divider for the SYS PLL"]
    #[doc = " \\param post_div2_out On success, The second post divider for the SYS PLL."]
    #[doc = " @return true if the frequency is possible and the output parameters have been written."]
    pub fn check_sys_clock_khz(
        freq_khz: u32,
        vco_freq_out: *mut uint,
        post_div1_out: *mut uint,
        post_div2_out: *mut uint,
    ) -> bool;
}
#[doc = " \\brief A spin lock identifier"]
#[doc = " \\ingroup hardware_sync"]
pub type spin_lock_t = u32;
extern "C" {
    #[doc = " \\brief Initialise a spin lock"]
    #[doc = "  \\ingroup hardware_sync"]
    #[doc = ""]
    #[doc = " The spin lock is initially unlocked"]
    #[doc = ""]
    #[doc = " \\param lock_num The spin lock number"]
    #[doc = " \\return The spin lock instance"]
    pub fn spin_lock_init(lock_num: uint) -> *mut spin_lock_t;
}
extern "C" {
    #[doc = " \\brief Release all spin locks"]
    #[doc = "  \\ingroup hardware_sync"]
    pub fn spin_locks_reset();
}
extern "C" {
    #[doc = " \\brief Return a spin lock number from the _striped_ range"]
    #[doc = "  \\ingroup hardware_sync"]
    #[doc = ""]
    #[doc = " Returns a spin lock number in the range PICO_SPINLOCK_ID_STRIPED_FIRST to PICO_SPINLOCK_ID_STRIPED_LAST"]
    #[doc = " in a round robin fashion. This does not grant the caller exclusive access to the spin lock, so the caller"]
    #[doc = " must:"]
    #[doc = ""]
    #[doc = " -# Abide (with other callers) by the contract of only holding this spin lock briefly (and with IRQs disabled - the default via \\ref spin_lock_blocking()),"]
    #[doc = " and not whilst holding other spin locks."]
    #[doc = " -# Be OK with any contention caused by the - brief due to the above requirement - contention with other possible users of the spin lock."]
    #[doc = ""]
    #[doc = " \\return lock_num a spin lock number the caller may use (non exclusively)"]
    #[doc = " \\see PICO_SPINLOCK_ID_STRIPED_FIRST"]
    #[doc = " \\see PICO_SPINLOCK_ID_STRIPED_LAST"]
    pub fn next_striped_spin_lock_num() -> uint;
}
extern "C" {
    #[doc = " \\brief Mark a spin lock as used"]
    #[doc = "  \\ingroup hardware_sync"]
    #[doc = ""]
    #[doc = " Method for cooperative claiming of hardware. Will cause a panic if the spin lock"]
    #[doc = " is already claimed. Use of this method by libraries detects accidental"]
    #[doc = " configurations that would fail in unpredictable ways."]
    #[doc = ""]
    #[doc = " \\param lock_num the spin lock number"]
    pub fn spin_lock_claim(lock_num: uint);
}
extern "C" {
    #[doc = " \\brief Mark multiple spin locks as used"]
    #[doc = "  \\ingroup hardware_sync"]
    #[doc = ""]
    #[doc = " Method for cooperative claiming of hardware. Will cause a panic if any of the spin locks"]
    #[doc = " are already claimed. Use of this method by libraries detects accidental"]
    #[doc = " configurations that would fail in unpredictable ways."]
    #[doc = ""]
    #[doc = " \\param lock_num_mask Bitfield of all required spin locks to claim (bit 0 == spin lock 0, bit 1 == spin lock 1 etc)"]
    pub fn spin_lock_claim_mask(lock_num_mask: u32);
}
extern "C" {
    #[doc = " \\brief Mark a spin lock as no longer used"]
    #[doc = "  \\ingroup hardware_sync"]
    #[doc = ""]
    #[doc = " Method for cooperative claiming of hardware."]
    #[doc = ""]
    #[doc = " \\param lock_num the spin lock number to release"]
    pub fn spin_lock_unclaim(lock_num: uint);
}
extern "C" {
    #[doc = " \\brief Claim a free spin lock"]
    #[doc = "  \\ingroup hardware_sync"]
    #[doc = ""]
    #[doc = " \\param required if true the function will panic if none are available"]
    #[doc = " \\return the spin lock number or -1 if required was false, and none were free"]
    pub fn spin_lock_claim_unused(required: bool) -> crate::ctypes::c_int;
}
extern "C" {
    #[doc = " \\brief Determine if a spin lock is claimed"]
    #[doc = "  \\ingroup hardware_sync"]
    #[doc = ""]
    #[doc = " \\param lock_num the spin lock number"]
    #[doc = " \\return true if claimed, false otherwise"]
    #[doc = " \\see spin_lock_claim"]
    #[doc = " \\see spin_lock_claim_mask"]
    pub fn spin_lock_is_claimed(lock_num: uint) -> bool;
}
#[doc = " \\brief Interrupt handler function type"]
#[doc = "  \\ingroup hardware_irq"]
#[doc = ""]
#[doc = " All interrupts handlers should be of this type, and follow normal ARM EABI register saving conventions"]
pub type irq_handler_t = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[doc = " \\brief Set specified interrupts priority"]
    #[doc = "  \\ingroup hardware_irq"]
    #[doc = ""]
    #[doc = " \\param num Interrupt number"]
    #[doc = " \\param hardware_priority Priority to set."]
    #[doc = " Numerically-lower values indicate a higher priority. Hardware priorities"]
    #[doc = " range from 0 (highest priority) to 255 (lowest priority) though only the"]
    #[doc = " top 2 bits are significant on ARM Cortex-M0+. To make it easier to specify"]
    #[doc = " higher or lower priorities than the default, all IRQ priorities are"]
    #[doc = " initialized to PICO_DEFAULT_IRQ_PRIORITY by the SDK runtime at startup."]
    #[doc = " PICO_DEFAULT_IRQ_PRIORITY defaults to 0x80"]
    pub fn irq_set_priority(num: uint, hardware_priority: u8);
}
extern "C" {
    #[doc = " \\brief Enable or disable a specific interrupt on the executing core"]
    #[doc = "  \\ingroup hardware_irq"]
    #[doc = ""]
    #[doc = " \\param num Interrupt number \\ref interrupt_nums"]
    #[doc = " \\param enabled true to enable the interrupt, false to disable"]
    pub fn irq_set_enabled(num: uint, enabled: bool);
}
extern "C" {
    #[doc = " \\brief Determine if a specific interrupt is enabled on the executing core"]
    #[doc = "  \\ingroup hardware_irq"]
    #[doc = ""]
    #[doc = " \\param num Interrupt number \\ref interrupt_nums"]
    #[doc = " \\return true if the interrupt is enabled"]
    pub fn irq_is_enabled(num: uint) -> bool;
}
extern "C" {
    #[doc = " \\brief Enable/disable multiple interrupts on the executing core"]
    #[doc = "  \\ingroup hardware_irq"]
    #[doc = ""]
    #[doc = " \\param mask 32-bit mask with one bits set for the interrupts to enable/disable"]
    #[doc = " \\param enabled true to enable the interrupts, false to disable them."]
    pub fn irq_set_mask_enabled(mask: u32, enabled: bool);
}
extern "C" {
    #[doc = " \\brief  Set an exclusive interrupt handler for an interrupt on the executing core."]
    #[doc = "  \\ingroup hardware_irq"]
    #[doc = ""]
    #[doc = " Use this method to set a handler for single IRQ source interrupts, or when"]
    #[doc = " your code, use case or performance requirements dictate that there should"]
    #[doc = " no other handlers for the interrupt."]
    #[doc = ""]
    #[doc = " This method will assert if there is already any sort of interrupt handler installed"]
    #[doc = " for the specified irq number."]
    #[doc = ""]
    #[doc = " \\param num Interrupt number \\ref interrupt_nums"]
    #[doc = " \\param handler The handler to set. See \\ref irq_handler_t"]
    #[doc = " \\see irq_add_shared_handler()"]
    pub fn irq_set_exclusive_handler(num: uint, handler: irq_handler_t);
}
extern "C" {
    #[doc = " \\brief  Get the exclusive interrupt handler for an interrupt on the executing core."]
    #[doc = "  \\ingroup hardware_irq"]
    #[doc = ""]
    #[doc = " This method will return an exclusive IRQ handler set on this core"]
    #[doc = " by irq_set_exclusive_handler if there is one."]
    #[doc = ""]
    #[doc = " \\param num Interrupt number \\ref interrupt_nums"]
    #[doc = " \\see irq_set_exclusive_handler()"]
    #[doc = " \\return handler The handler if an exclusive handler is set for the IRQ,"]
    #[doc = "                 NULL if no handler is set or shared/shareable handlers are installed"]
    pub fn irq_get_exclusive_handler(num: uint) -> irq_handler_t;
}
extern "C" {
    #[doc = " \\brief Add a shared interrupt handler for an interrupt on the executing core"]
    #[doc = "  \\ingroup hardware_irq"]
    #[doc = ""]
    #[doc = " Use this method to add a handler on an irq number shared between multiple distinct hardware sources (e.g. GPIO, DMA or PIO IRQs)."]
    #[doc = " Handlers added by this method will all be called in sequence from highest order_priority to lowest. The"]
    #[doc = " irq_set_exclusive_handler() method should be used instead if you know there will or should only ever be one handler for the interrupt."]
    #[doc = ""]
    #[doc = " This method will assert if there is an exclusive interrupt handler set for this irq number on this core, or if"]
    #[doc = " the (total across all IRQs on both cores) maximum (configurable via PICO_MAX_SHARED_IRQ_HANDLERS) number of shared handlers"]
    #[doc = " would be exceeded."]
    #[doc = ""]
    #[doc = " \\param num Interrupt number"]
    #[doc = " \\param handler The handler to set. See \\ref irq_handler_t"]
    #[doc = " \\param order_priority The order priority controls the order that handlers for the same IRQ number on the core are called."]
    #[doc = " The shared irq handlers for an interrupt are all called when an IRQ fires, however the order of the calls is based"]
    #[doc = " on the order_priority (higher priorities are called first, identical priorities are called in undefined order). A good"]
    #[doc = " rule of thumb is to use PICO_SHARED_IRQ_HANDLER_DEFAULT_ORDER_PRIORITY if you don't much care, as it is in the middle of"]
    #[doc = " the priority range by default."]
    #[doc = ""]
    #[doc = " \\see irq_set_exclusive_handler()"]
    pub fn irq_add_shared_handler(num: uint, handler: irq_handler_t, order_priority: u8);
}
extern "C" {
    #[doc = " \\brief Remove a specific interrupt handler for the given irq number on the executing core"]
    #[doc = "  \\ingroup hardware_irq"]
    #[doc = ""]
    #[doc = " This method may be used to remove an irq set via either irq_set_exclusive_handler() or"]
    #[doc = " irq_add_shared_handler(), and will assert if the handler is not currently installed for the given"]
    #[doc = " IRQ number"]
    #[doc = ""]
    #[doc = " \\note This method may *only* be called from user (non IRQ code) or from within the handler"]
    #[doc = " itself (i.e. an IRQ handler may remove itself as part of handling the IRQ). Attempts to call"]
    #[doc = " from another IRQ will cause an assertion."]
    #[doc = ""]
    #[doc = " \\param num Interrupt number \\ref interrupt_nums"]
    #[doc = " \\param handler The handler to removed."]
    #[doc = " \\see irq_set_exclusive_handler()"]
    #[doc = " \\see irq_add_shared_handler()"]
    pub fn irq_remove_handler(num: uint, handler: irq_handler_t);
}
extern "C" {
    #[doc = " \\brief Get the current IRQ handler for the specified IRQ from the currently installed hardware vector table (VTOR)"]
    #[doc = " of the execution core"]
    #[doc = "  \\ingroup hardware_irq"]
    #[doc = ""]
    #[doc = " \\param num Interrupt number \\ref interrupt_nums"]
    #[doc = " \\return the address stored in the VTABLE for the given irq number"]
    pub fn irq_get_vtable_handler(num: uint) -> irq_handler_t;
}
extern "C" {
    #[doc = " \\brief Force an interrupt to pending on the executing core"]
    #[doc = "  \\ingroup hardware_irq"]
    #[doc = ""]
    #[doc = " This should generally not be used for IRQs connected to hardware."]
    #[doc = ""]
    #[doc = " \\param num Interrupt number \\ref interrupt_nums"]
    pub fn irq_set_pending(num: uint);
}
extern "C" {
    #[doc = " \\brief Perform IRQ priority initialization for the current core"]
    #[doc = ""]
    #[doc = " \\note This is an internal method and user should generally not call it."]
    pub fn irq_init_priorities();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtc_hw_t {
    pub clkdiv_m1: io_rw_32,
    pub setup_0: io_rw_32,
    pub setup_1: io_rw_32,
    pub ctrl: io_rw_32,
    pub irq_setup_0: io_rw_32,
    pub irq_setup_1: io_rw_32,
    pub rtc_1: io_rw_32,
    pub rtc_0: io_rw_32,
    pub intr: io_rw_32,
    pub inte: io_rw_32,
    pub intf: io_rw_32,
    pub ints: io_rw_32,
}
#[doc = " Callback function type for RTC alarms"]
#[doc = "  \\ingroup hardware_rtc"]
#[doc = ""]
#[doc = " \\sa rtc_set_alarm()"]
pub type rtc_callback_t = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[doc = " \\brief Initialise the RTC system"]
    #[doc = "  \\ingroup hardware_rtc"]
    pub fn rtc_init();
}
extern "C" {
    #[doc = " \\brief Set the RTC to the specified time"]
    #[doc = "  \\ingroup hardware_rtc"]
    #[doc = ""]
    #[doc = " \\param t Pointer to a \\ref datetime_t structure contains time to set"]
    #[doc = " \\return true if set, false if the passed in datetime was invalid."]
    pub fn rtc_set_datetime(t: *mut datetime_t) -> bool;
}
extern "C" {
    #[doc = " \\brief Get the current time from the RTC"]
    #[doc = "  \\ingroup hardware_rtc"]
    #[doc = ""]
    #[doc = " \\param t Pointer to a \\ref datetime_t structure to receive the current RTC time"]
    #[doc = " \\return true if datetime is valid, false if the RTC is not running."]
    pub fn rtc_get_datetime(t: *mut datetime_t) -> bool;
}
extern "C" {
    #[doc = " \\brief Is the RTC running?"]
    #[doc = "  \\ingroup hardware_rtc"]
    #[doc = ""]
    pub fn rtc_running() -> bool;
}
extern "C" {
    #[doc = " \\brief Set a time in the future for the RTC to call a user provided callback"]
    #[doc = "  \\ingroup hardware_rtc"]
    #[doc = ""]
    #[doc = "  \\param t Pointer to a \\ref datetime_t structure containing a time in the future to fire the alarm. Any values set to -1 will not be matched on."]
    #[doc = "  \\param user_callback pointer to a \\ref rtc_callback_t to call when the alarm fires"]
    pub fn rtc_set_alarm(t: *mut datetime_t, user_callback: rtc_callback_t);
}
extern "C" {
    #[doc = " \\brief Enable the RTC alarm (if inactive)"]
    #[doc = "  \\ingroup hardware_rtc"]
    pub fn rtc_enable_alarm();
}
extern "C" {
    #[doc = " \\brief Disable the RTC alarm (if active)"]
    #[doc = "  \\ingroup hardware_rtc"]
    pub fn rtc_disable_alarm();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pwm_slice_hw {
    pub csr: io_rw_32,
    pub div: io_rw_32,
    pub ctr: io_rw_32,
    pub cc: io_rw_32,
    pub top: io_rw_32,
}
pub type pwm_slice_hw_t = pwm_slice_hw;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pwm_hw_t {
    pub slice: [pwm_slice_hw_t; 8usize],
    pub en: io_rw_32,
    pub intr: io_rw_32,
    pub inte: io_rw_32,
    pub intf: io_rw_32,
    pub ints: io_rw_32,
}
#[doc = "< Free-running counting at rate dictated by fractional divider"]
pub const PWM_DIV_FREE_RUNNING: pwm_clkdiv_mode = 0;
#[doc = "< Fractional divider is gated by the PWM B pin"]
pub const PWM_DIV_B_HIGH: pwm_clkdiv_mode = 1;
#[doc = "< Fractional divider advances with each rising edge of the PWM B pin"]
pub const PWM_DIV_B_RISING: pwm_clkdiv_mode = 2;
#[doc = "< Fractional divider advances with each falling edge of the PWM B pin"]
pub const PWM_DIV_B_FALLING: pwm_clkdiv_mode = 3;
#[doc = " \\brief PWM Divider mode settings"]
#[doc = "   \\ingroup hardware_pwm"]
#[doc = ""]
pub type pwm_clkdiv_mode = crate::ctypes::c_uint;
pub const PWM_CHAN_A: pwm_chan = 0;
pub const PWM_CHAN_B: pwm_chan = 1;
pub type pwm_chan = crate::ctypes::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pwm_config {
    pub csr: u32,
    pub div: u32,
    pub top: u32,
}
extern "C" {
    pub fn binding_uart0_init(
        baud_rate: uint,
        tx_pin: uint,
        rx_pin: uint,
    ) -> *mut crate::ctypes::c_void;
}
extern "C" {
    pub fn binding_uart_destroy(uart: *mut crate::ctypes::c_void);
}
extern "C" {
    pub fn binding_uart_write_blocking(
        uart: *mut crate::ctypes::c_void,
        data: *const u8,
        len: uint,
    );
}
extern "C" {
    pub fn binding_uart_read_blocking(uart: *mut crate::ctypes::c_void, data: *mut u8, len: uint);
}
extern "C" {
    pub fn binding_uart_set_irq_enables(uart: *mut crate::ctypes::c_void, rx: bool, tx: bool);
}
extern "C" {
    pub fn binding_uart_is_readable(uart: *mut crate::ctypes::c_void) -> bool;
}
extern "C" {
    pub fn binding_uart_getc(uart: *mut crate::ctypes::c_void) -> u8;
}
extern "C" {
    pub fn binding_irq_set_exclusive_handler(
        irq: uint,
        fn_: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    pub fn binding_irq_set_enabled(irq: uint, enabled: bool);
}
extern "C" {
    pub fn binding_gpio_set_dir(gpio: uint, out: bool);
}
extern "C" {
    pub fn binding_gpio_put(gpio: uint, value: bool);
}
extern "C" {
    pub fn binding_gpio_get(gpio: uint) -> bool;
}
extern "C" {
    pub fn binding_pwm_gpio_to_slice_num(gpio: uint) -> uint;
}
extern "C" {
    pub fn binding_pwm_get_default_config() -> pwm_config;
}
extern "C" {
    pub fn binding_pwm_init(slice_num: uint, config: *mut pwm_config, running: bool);
}
extern "C" {
    pub fn binding_pwm_set_gpio_level(gpio: uint, level: u16);
}
extern "C" {
    pub fn binding_save_and_disable_interrupts() -> u32;
}
extern "C" {
    pub fn binding_restore_interrupts(status: u32);
}
